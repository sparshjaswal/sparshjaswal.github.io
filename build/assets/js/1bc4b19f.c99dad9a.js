"use strict";(globalThis.webpackChunka=globalThis.webpackChunka||[]).push([[3241],{1443:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"design-pattern/behavioral/memento","title":"Memento Pattern \ud83d\udcbe","description":"Definition: The Memento pattern captures and stores the internal state of an object without violating encapsulation, so that the object can be restored to this state later.","source":"@site/docs/design-pattern/behavioral/memento.md","sourceDirName":"design-pattern/behavioral","slug":"/design-pattern/behavioral/memento","permalink":"/docs/design-pattern/behavioral/memento","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Mediator Pattern \ud83c\udfad","permalink":"/docs/design-pattern/behavioral/mediator"},"next":{"title":"Observer Pattern \ud83d\udd14","permalink":"/docs/design-pattern/behavioral/observer"}}');var o=t(4848),s=t(8453);const i={},a="Memento Pattern \ud83d\udcbe",l={},c=[{value:"\ud83c\udfaf Intent",id:"-intent",level:2},{value:"\ud83e\udd14 Problem",id:"-problem",level:2},{value:"\ud83d\udca1 Solution",id:"-solution",level:2},{value:"\ud83c\udfd7\ufe0f Structure",id:"\ufe0f-structure",level:2},{value:"\ud83d\udcbb Simple Example",id:"-simple-example",level:2},{value:"Text Editor with Undo/Redo",id:"text-editor-with-undoredo",level:3},{value:"\ud83c\udf1f Real-World Example",id:"-real-world-example",level:2},{value:"Game Save System",id:"game-save-system",level:3},{value:"\u2705 Pros",id:"-pros",level:2},{value:"\u274c Cons",id:"-cons",level:2},{value:"\ud83c\udfaf When to Use",id:"-when-to-use",level:2},{value:"\ud83d\udd04 Memento Variations",id:"-memento-variations",level:2},{value:"1. <strong>Command-based Memento</strong>",id:"1-command-based-memento",level:3},{value:"2. <strong>Incremental Memento</strong>",id:"2-incremental-memento",level:3},{value:"3. <strong>Compressed Memento</strong>",id:"3-compressed-memento",level:3},{value:"\ud83d\udd17 Related Patterns",id:"-related-patterns",level:2},{value:"\ud83d\udcda Further Reading",id:"-further-reading",level:2}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"memento-pattern-",children:"Memento Pattern \ud83d\udcbe"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Definition"}),": The Memento pattern captures and stores the internal state of an object without violating encapsulation, so that the object can be restored to this state later."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"-intent",children:"\ud83c\udfaf Intent"}),"\n",(0,o.jsx)(n.p,{children:"Without violating encapsulation, capture and externalize an object's internal state so that the object can be restored to this state later. This is useful for implementing undo/redo functionality."}),"\n",(0,o.jsx)(n.h2,{id:"-problem",children:"\ud83e\udd14 Problem"}),"\n",(0,o.jsx)(n.p,{children:"You need to save and restore object states, but:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Encapsulation"}),": Direct access to object's private state breaks encapsulation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Undo/Redo"}),": Need to implement undo/redo functionality"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Snapshots"}),": Want to create snapshots of object state at different points"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"State History"}),": Need to maintain history of state changes"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Making object state public breaks encapsulation, but you need access to save/restore it."}),"\n",(0,o.jsx)(n.h2,{id:"-solution",children:"\ud83d\udca1 Solution"}),"\n",(0,o.jsx)(n.p,{children:"The Memento pattern suggests storing the object's state in a special object called a memento. The memento is only accessible to the object that created it (originator), maintaining encapsulation while allowing state restoration."}),"\n",(0,o.jsx)(n.h2,{id:"\ufe0f-structure",children:"\ud83c\udfd7\ufe0f Structure"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Originator\r\n\u251c\u2500\u2500 -state: any\r\n\u251c\u2500\u2500 +createMemento(): Memento\r\n\u251c\u2500\u2500 +restore(memento: Memento): void\r\n\u2514\u2500\u2500 +setState(state): void\r\n\r\nMemento\r\n\u251c\u2500\u2500 -state: any\r\n\u251c\u2500\u2500 +constructor(state: any)\r\n\u2514\u2500\u2500 +getState(): any (only accessible to Originator)\r\n\r\nCaretaker\r\n\u251c\u2500\u2500 -mementos: Memento[]\r\n\u251c\u2500\u2500 +backup(originator: Originator): void\r\n\u251c\u2500\u2500 +undo(originator: Originator): void\r\n\u2514\u2500\u2500 +showHistory(): void\n"})}),"\n",(0,o.jsx)(n.h2,{id:"-simple-example",children:"\ud83d\udcbb Simple Example"}),"\n",(0,o.jsx)(n.h3,{id:"text-editor-with-undoredo",children:"Text Editor with Undo/Redo"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'// Memento - stores the state\r\nclass TextMemento {\r\n  constructor(content, cursorPosition, selectionStart, selectionEnd) {\r\n    this._content = content;\r\n    this._cursorPosition = cursorPosition;\r\n    this._selectionStart = selectionStart;\r\n    this._selectionEnd = selectionEnd;\r\n    this._timestamp = new Date();\r\n  }\r\n  \r\n  // Private state access - only TextEditor can access these\r\n  getContent() {\r\n    return this._content;\r\n  }\r\n  \r\n  getCursorPosition() {\r\n    return this._cursorPosition;\r\n  }\r\n  \r\n  getSelectionStart() {\r\n    return this._selectionStart;\r\n  }\r\n  \r\n  getSelectionEnd() {\r\n    return this._selectionEnd;\r\n  }\r\n  \r\n  getTimestamp() {\r\n    return this._timestamp;\r\n  }\r\n  \r\n  getPreview() {\r\n    const preview = this._content.substring(0, 50);\r\n    return preview + (this._content.length > 50 ? \'...\' : \'\');\r\n  }\r\n}\r\n\r\n// Originator - creates and restores mementos\r\nclass TextEditor {\r\n  constructor() {\r\n    this.content = \'\';\r\n    this.cursorPosition = 0;\r\n    this.selectionStart = 0;\r\n    this.selectionEnd = 0;\r\n    this.filename = \'Untitled.txt\';\r\n  }\r\n  \r\n  // Create memento with current state\r\n  createMemento() {\r\n    console.log(`\ud83d\udcbe Creating backup of current state`);\r\n    return new TextMemento(\r\n      this.content,\r\n      this.cursorPosition,\r\n      this.selectionStart,\r\n      this.selectionEnd\r\n    );\r\n  }\r\n  \r\n  // Restore state from memento\r\n  restore(memento) {\r\n    console.log(`\ud83d\udd04 Restoring state from ${memento.getTimestamp().toLocaleTimeString()}`);\r\n    this.content = memento.getContent();\r\n    this.cursorPosition = memento.getCursorPosition();\r\n    this.selectionStart = memento.getSelectionStart();\r\n    this.selectionEnd = memento.getSelectionEnd();\r\n    \r\n    console.log(`\u2705 State restored: "${memento.getPreview()}"`);\r\n  }\r\n  \r\n  // Editor operations\r\n  type(text) {\r\n    // Insert text at cursor position\r\n    const before = this.content.substring(0, this.cursorPosition);\r\n    const after = this.content.substring(this.cursorPosition);\r\n    \r\n    this.content = before + text + after;\r\n    this.cursorPosition += text.length;\r\n    \r\n    console.log(`\u2328\ufe0f Typed: "${text}" at position ${this.cursorPosition - text.length}`);\r\n    this.displayState();\r\n  }\r\n  \r\n  delete(count = 1) {\r\n    if (this.cursorPosition > 0) {\r\n      const deleteCount = Math.min(count, this.cursorPosition);\r\n      const before = this.content.substring(0, this.cursorPosition - deleteCount);\r\n      const after = this.content.substring(this.cursorPosition);\r\n      \r\n      this.content = before + after;\r\n      this.cursorPosition -= deleteCount;\r\n      \r\n      console.log(`\ud83d\uddd1\ufe0f Deleted ${deleteCount} character(s)`);\r\n      this.displayState();\r\n    }\r\n  }\r\n  \r\n  selectText(start, end) {\r\n    this.selectionStart = Math.max(0, Math.min(start, this.content.length));\r\n    this.selectionEnd = Math.max(this.selectionStart, Math.min(end, this.content.length));\r\n    \r\n    const selectedText = this.content.substring(this.selectionStart, this.selectionEnd);\r\n    console.log(`\ud83c\udfaf Selected: "${selectedText}" (${this.selectionStart}-${this.selectionEnd})`);\r\n  }\r\n  \r\n  replaceSelection(text) {\r\n    if (this.selectionStart !== this.selectionEnd) {\r\n      const before = this.content.substring(0, this.selectionStart);\r\n      const after = this.content.substring(this.selectionEnd);\r\n      \r\n      this.content = before + text + after;\r\n      this.cursorPosition = this.selectionStart + text.length;\r\n      this.selectionStart = this.selectionEnd = this.cursorPosition;\r\n      \r\n      console.log(`\ud83d\udd04 Replaced selection with: "${text}"`);\r\n      this.displayState();\r\n    }\r\n  }\r\n  \r\n  moveCursor(position) {\r\n    this.cursorPosition = Math.max(0, Math.min(position, this.content.length));\r\n    console.log(`\ud83d\uddb1\ufe0f Cursor moved to position ${this.cursorPosition}`);\r\n  }\r\n  \r\n  displayState() {\r\n    const preview = this.content.substring(0, 80);\r\n    const displayContent = preview + (this.content.length > 80 ? \'...\' : \'\');\r\n    \r\n    console.log(`\ud83d\udcc4 Current content: "${displayContent}"`);\r\n    console.log(`   Length: ${this.content.length}, Cursor: ${this.cursorPosition}`);\r\n    \r\n    if (this.selectionStart !== this.selectionEnd) {\r\n      console.log(`   Selection: ${this.selectionStart}-${this.selectionEnd}`);\r\n    }\r\n  }\r\n  \r\n  getStats() {\r\n    const wordCount = this.content.trim() ? this.content.trim().split(/\\s+/).length : 0;\r\n    const lineCount = this.content.split(\'\\n\').length;\r\n    \r\n    return {\r\n      characters: this.content.length,\r\n      words: wordCount,\r\n      lines: lineCount,\r\n      cursorPosition: this.cursorPosition\r\n    };\r\n  }\r\n}\r\n\r\n// Caretaker - manages mementos\r\nclass EditorHistory {\r\n  constructor(maxHistory = 50) {\r\n    this.history = [];\r\n    this.currentIndex = -1;\r\n    this.maxHistory = maxHistory;\r\n  }\r\n  \r\n  // Save current state\r\n  backup(editor) {\r\n    const memento = editor.createMemento();\r\n    \r\n    // Remove any forward history if we\'re not at the end\r\n    if (this.currentIndex < this.history.length - 1) {\r\n      this.history = this.history.slice(0, this.currentIndex + 1);\r\n    }\r\n    \r\n    // Add new memento\r\n    this.history.push(memento);\r\n    this.currentIndex++;\r\n    \r\n    // Keep history within limits\r\n    if (this.history.length > this.maxHistory) {\r\n      this.history.shift();\r\n      this.currentIndex--;\r\n    }\r\n    \r\n    console.log(`\ud83d\udcbe Backup created (${this.currentIndex + 1}/${this.history.length})`);\r\n  }\r\n  \r\n  // Undo last operation\r\n  undo(editor) {\r\n    if (this.currentIndex > 0) {\r\n      this.currentIndex--;\r\n      const memento = this.history[this.currentIndex];\r\n      editor.restore(memento);\r\n      \r\n      console.log(`\u21b6 Undo successful (${this.currentIndex + 1}/${this.history.length})`);\r\n      return true;\r\n    } else {\r\n      console.log(`\u274c No more operations to undo`);\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  // Redo next operation\r\n  redo(editor) {\r\n    if (this.currentIndex < this.history.length - 1) {\r\n      this.currentIndex++;\r\n      const memento = this.history[this.currentIndex];\r\n      editor.restore(memento);\r\n      \r\n      console.log(`\u21b7 Redo successful (${this.currentIndex + 1}/${this.history.length})`);\r\n      return true;\r\n    } else {\r\n      console.log(`\u274c No more operations to redo`);\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  // Show history\r\n  showHistory() {\r\n    console.log(`\ud83d\udcda Editor History (${this.history.length} states):`);\r\n    console.log(`   Current position: ${this.currentIndex + 1}/${this.history.length}`);\r\n    \r\n    this.history.forEach((memento, index) => {\r\n      const marker = index === this.currentIndex ? \'\u2192\' : \' \';\r\n      const time = memento.getTimestamp().toLocaleTimeString();\r\n      const preview = memento.getPreview();\r\n      \r\n      console.log(`   ${marker} ${index + 1}. ${time} - "${preview}"`);\r\n    });\r\n  }\r\n  \r\n  // Clear history\r\n  clearHistory() {\r\n    const clearedCount = this.history.length;\r\n    this.history = [];\r\n    this.currentIndex = -1;\r\n    \r\n    console.log(`\ud83d\uddd1\ufe0f Cleared ${clearedCount} history states`);\r\n  }\r\n  \r\n  canUndo() {\r\n    return this.currentIndex > 0;\r\n  }\r\n  \r\n  canRedo() {\r\n    return this.currentIndex < this.history.length - 1;\r\n  }\r\n}\r\n\r\n// Usage\r\nconsole.log("=== Text Editor Memento Demo ===\\n");\r\n\r\nconsole.log("Creating text editor:");\r\nconsole.log("-".repeat(20));\r\n\r\nconst editor = new TextEditor();\r\nconst history = new EditorHistory();\r\n\r\n// Initial backup\r\nhistory.backup(editor);\r\n\r\nconsole.log("Starting to type:");\r\nconsole.log("-".repeat(17));\r\n\r\neditor.type("Hello");\r\nhistory.backup(editor);\r\n\r\neditor.type(" World");\r\nhistory.backup(editor);\r\n\r\neditor.type("!");\r\nhistory.backup(editor);\r\n\r\nconsole.log("\\n" + "=".repeat(50) + "\\n");\r\n\r\nconsole.log("Making some edits:");\r\nconsole.log("-".repeat(18));\r\n\r\neditor.selectText(6, 11); // Select "World"\r\nhistory.backup(editor);\r\n\r\neditor.replaceSelection("JavaScript");\r\nhistory.backup(editor);\r\n\r\neditor.type(" Programming");\r\nhistory.backup(editor);\r\n\r\nconsole.log("\\n" + "=".repeat(50) + "\\n");\r\n\r\nconsole.log("History overview:");\r\nconsole.log("-".repeat(16));\r\n\r\nhistory.showHistory();\r\n\r\nconsole.log("\\n" + "=".repeat(50) + "\\n");\r\n\r\nconsole.log("Testing undo operations:");\r\nconsole.log("-".repeat(25));\r\n\r\n// Undo several operations\r\nhistory.undo(editor);\r\nconsole.log();\r\n\r\nhistory.undo(editor);\r\nconsole.log();\r\n\r\nhistory.undo(editor);\r\n\r\nconsole.log("\\nAfter undos:");\r\nconsole.log("-".repeat(12));\r\neditor.displayState();\r\n\r\nconsole.log("\\n" + "-".repeat(30) + "\\n");\r\n\r\nconsole.log("Testing redo operations:");\r\nconsole.log("-".repeat(25));\r\n\r\nhistory.redo(editor);\r\nconsole.log();\r\n\r\nhistory.redo(editor);\r\n\r\nconsole.log("\\nAfter redos:");\r\nconsole.log("-".repeat(12));\r\neditor.displayState();\r\n\r\nconsole.log("\\n" + "=".repeat(50) + "\\n");\r\n\r\nconsole.log("Final editor statistics:");\r\nconsole.log("-".repeat(25));\r\n\r\nconst stats = editor.getStats();\r\nconsole.log(`\ud83d\udcca Editor Stats:`);\r\nconsole.log(`   Characters: ${stats.characters}`);\r\nconsole.log(`   Words: ${stats.words}`);\r\nconsole.log(`   Lines: ${stats.lines}`);\r\nconsole.log(`   Cursor Position: ${stats.cursorPosition}`);\r\n\r\nconsole.log(`\\n\ud83d\udd52 History: ${history.canUndo() ? \'Can undo\' : \'Cannot undo\'}, ${history.canRedo() ? \'Can redo\' : \'Cannot redo\'}`);\n'})}),"\n",(0,o.jsx)(n.h2,{id:"-real-world-example",children:"\ud83c\udf1f Real-World Example"}),"\n",(0,o.jsx)(n.h3,{id:"game-save-system",children:"Game Save System"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'// Memento for game state\r\nclass GameSaveMemento {\r\n  constructor(gameState) {\r\n    this._playerData = { ...gameState.playerData };\r\n    this._gameWorld = { ...gameState.gameWorld };\r\n    this._inventory = [...gameState.inventory];\r\n    this._achievements = [...gameState.achievements];\r\n    this._settings = { ...gameState.settings };\r\n    this._timestamp = new Date();\r\n    this._saveVersion = \'1.0.0\';\r\n  }\r\n  \r\n  getPlayerData() { return this._playerData; }\r\n  getGameWorld() { return this._gameWorld; }\r\n  getInventory() { return this._inventory; }\r\n  getAchievements() { return this._achievements; }\r\n  getSettings() { return this._settings; }\r\n  getTimestamp() { return this._timestamp; }\r\n  getSaveVersion() { return this._saveVersion; }\r\n  \r\n  getSaveInfo() {\r\n    return {\r\n      playerLevel: this._playerData.level,\r\n      location: this._gameWorld.currentLocation,\r\n      playTime: this._playerData.totalPlayTime,\r\n      timestamp: this._timestamp\r\n    };\r\n  }\r\n}\r\n\r\n// Game state originator\r\nclass GameEngine {\r\n  constructor() {\r\n    this.playerData = {\r\n      name: \'Player\',\r\n      level: 1,\r\n      health: 100,\r\n      mana: 50,\r\n      experience: 0,\r\n      gold: 100,\r\n      totalPlayTime: 0\r\n    };\r\n    \r\n    this.gameWorld = {\r\n      currentLocation: \'Starting Village\',\r\n      visitedLocations: [\'Starting Village\'],\r\n      completedQuests: [],\r\n      worldSeed: Math.random()\r\n    };\r\n    \r\n    this.inventory = [\r\n      { name: \'Wooden Sword\', type: \'weapon\', damage: 10 },\r\n      { name: \'Health Potion\', type: \'consumable\', quantity: 3 }\r\n    ];\r\n    \r\n    this.achievements = [];\r\n    \r\n    this.settings = {\r\n      difficulty: \'normal\',\r\n      soundVolume: 0.8,\r\n      musicVolume: 0.6,\r\n      graphics: \'medium\'\r\n    };\r\n    \r\n    this.sessionStartTime = Date.now();\r\n  }\r\n  \r\n  // Create save memento\r\n  createSave(saveSlotName) {\r\n    // Update play time\r\n    this.updatePlayTime();\r\n    \r\n    console.log(`\ud83d\udcbe Creating game save: ${saveSlotName}`);\r\n    console.log(`   Location: ${this.gameWorld.currentLocation}`);\r\n    console.log(`   Level: ${this.playerData.level}`);\r\n    console.log(`   Play Time: ${this.formatPlayTime(this.playerData.totalPlayTime)}`);\r\n    \r\n    return new GameSaveMemento({\r\n      playerData: this.playerData,\r\n      gameWorld: this.gameWorld,\r\n      inventory: this.inventory,\r\n      achievements: this.achievements,\r\n      settings: this.settings\r\n    });\r\n  }\r\n  \r\n  // Load from save memento\r\n  loadSave(memento) {\r\n    console.log(`\ud83d\udd04 Loading game save from ${memento.getTimestamp().toLocaleString()}`);\r\n    \r\n    this.playerData = { ...memento.getPlayerData() };\r\n    this.gameWorld = { ...memento.getGameWorld() };\r\n    this.inventory = [...memento.getInventory()];\r\n    this.achievements = [...memento.getAchievements()];\r\n    this.settings = { ...memento.getSettings() };\r\n    \r\n    this.sessionStartTime = Date.now();\r\n    \r\n    console.log(`\u2705 Game loaded successfully`);\r\n    console.log(`   Player: ${this.playerData.name} (Level ${this.playerData.level})`);\r\n    console.log(`   Location: ${this.gameWorld.currentLocation}`);\r\n    console.log(`   Total Play Time: ${this.formatPlayTime(this.playerData.totalPlayTime)}`);\r\n  }\r\n  \r\n  // Game actions that modify state\r\n  levelUp() {\r\n    this.playerData.level++;\r\n    this.playerData.health += 20;\r\n    this.playerData.mana += 10;\r\n    this.playerData.experience = 0;\r\n    \r\n    console.log(`\u2b06\ufe0f Level Up! Now level ${this.playerData.level}`);\r\n    \r\n    if (this.playerData.level === 5) {\r\n      this.unlockAchievement(\'Apprentice Adventurer\');\r\n    }\r\n  }\r\n  \r\n  gainExperience(amount) {\r\n    this.playerData.experience += amount;\r\n    console.log(`\u2728 Gained ${amount} XP (${this.playerData.experience}/100)`);\r\n    \r\n    if (this.playerData.experience >= 100) {\r\n      this.levelUp();\r\n    }\r\n  }\r\n  \r\n  moveToLocation(location) {\r\n    this.gameWorld.currentLocation = location;\r\n    \r\n    if (!this.gameWorld.visitedLocations.includes(location)) {\r\n      this.gameWorld.visitedLocations.push(location);\r\n      console.log(`\ud83d\uddfa\ufe0f Discovered new location: ${location}`);\r\n      \r\n      if (this.gameWorld.visitedLocations.length >= 5) {\r\n        this.unlockAchievement(\'Explorer\');\r\n      }\r\n    } else {\r\n      console.log(`\ud83d\udeb6 Moved to: ${location}`);\r\n    }\r\n  }\r\n  \r\n  addToInventory(item) {\r\n    // Check if item already exists (for stackable items)\r\n    const existingItem = this.inventory.find(i => \r\n      i.name === item.name && i.type === item.type\r\n    );\r\n    \r\n    if (existingItem && item.quantity) {\r\n      existingItem.quantity = (existingItem.quantity || 1) + (item.quantity || 1);\r\n      console.log(`\ud83d\udce6 Added ${item.name} x${item.quantity || 1} to inventory`);\r\n    } else {\r\n      this.inventory.push(item);\r\n      console.log(`\ud83d\udce6 Added ${item.name} to inventory`);\r\n    }\r\n  }\r\n  \r\n  completeQuest(questName) {\r\n    if (!this.gameWorld.completedQuests.includes(questName)) {\r\n      this.gameWorld.completedQuests.push(questName);\r\n      console.log(`\u2705 Quest completed: ${questName}`);\r\n      \r\n      // Reward\r\n      this.gainExperience(25);\r\n      this.playerData.gold += 50;\r\n      \r\n      if (this.gameWorld.completedQuests.length >= 3) {\r\n        this.unlockAchievement(\'Quest Master\');\r\n      }\r\n    }\r\n  }\r\n  \r\n  unlockAchievement(achievementName) {\r\n    if (!this.achievements.includes(achievementName)) {\r\n      this.achievements.push(achievementName);\r\n      console.log(`\ud83c\udfc6 Achievement Unlocked: ${achievementName}`);\r\n    }\r\n  }\r\n  \r\n  updatePlayTime() {\r\n    const sessionTime = (Date.now() - this.sessionStartTime) / 1000;\r\n    this.playerData.totalPlayTime += sessionTime;\r\n    this.sessionStartTime = Date.now();\r\n  }\r\n  \r\n  formatPlayTime(seconds) {\r\n    const hours = Math.floor(seconds / 3600);\r\n    const minutes = Math.floor((seconds % 3600) / 60);\r\n    return `${hours}h ${minutes}m`;\r\n  }\r\n  \r\n  getGameStatus() {\r\n    console.log(`\ud83c\udfae Game Status:`);\r\n    console.log(`   Player: ${this.playerData.name} (Level ${this.playerData.level})`);\r\n    console.log(`   Health: ${this.playerData.health}/${this.playerData.health}`);\r\n    console.log(`   Gold: ${this.playerData.gold}`);\r\n    console.log(`   Location: ${this.gameWorld.currentLocation}`);\r\n    console.log(`   Quests Completed: ${this.gameWorld.completedQuests.length}`);\r\n    console.log(`   Achievements: ${this.achievements.length}`);\r\n    console.log(`   Inventory Items: ${this.inventory.length}`);\r\n    console.log(`   Play Time: ${this.formatPlayTime(this.playerData.totalPlayTime)}`);\r\n  }\r\n}\r\n\r\n// Save manager (caretaker)\r\nclass SaveManager {\r\n  constructor() {\r\n    this.saveSlots = new Map();\r\n    this.quickSaves = [];\r\n    this.maxQuickSaves = 5;\r\n    this.autoSaves = [];\r\n    this.maxAutoSaves = 10;\r\n  }\r\n  \r\n  // Manual save to named slot\r\n  save(game, slotName) {\r\n    const memento = game.createSave(slotName);\r\n    this.saveSlots.set(slotName, memento);\r\n    \r\n    console.log(`\ud83d\udcbe Game saved to slot: ${slotName}`);\r\n    return memento;\r\n  }\r\n  \r\n  // Load from named slot\r\n  load(game, slotName) {\r\n    if (this.saveSlots.has(slotName)) {\r\n      const memento = this.saveSlots.get(slotName);\r\n      game.loadSave(memento);\r\n      console.log(`\ud83d\udcc1 Loaded save from slot: ${slotName}`);\r\n      return true;\r\n    } else {\r\n      console.log(`\u274c Save slot not found: ${slotName}`);\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  // Quick save\r\n  quickSave(game) {\r\n    const memento = game.createSave(\'QuickSave\');\r\n    this.quickSaves.push(memento);\r\n    \r\n    // Keep only recent quick saves\r\n    if (this.quickSaves.length > this.maxQuickSaves) {\r\n      this.quickSaves.shift();\r\n    }\r\n    \r\n    console.log(`\u26a1 Quick save created (${this.quickSaves.length}/${this.maxQuickSaves})`);\r\n    return memento;\r\n  }\r\n  \r\n  // Quick load (most recent)\r\n  quickLoad(game) {\r\n    if (this.quickSaves.length > 0) {\r\n      const memento = this.quickSaves[this.quickSaves.length - 1];\r\n      game.loadSave(memento);\r\n      console.log(`\u26a1 Quick load successful`);\r\n      return true;\r\n    } else {\r\n      console.log(`\u274c No quick saves available`);\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  // Auto save (triggered automatically)\r\n  autoSave(game, trigger) {\r\n    const memento = game.createSave(`AutoSave-${trigger}`);\r\n    this.autoSaves.push({ memento, trigger, timestamp: new Date() });\r\n    \r\n    // Keep only recent auto saves\r\n    if (this.autoSaves.length > this.maxAutoSaves) {\r\n      this.autoSaves.shift();\r\n    }\r\n    \r\n    console.log(`\ud83e\udd16 Auto save created (${trigger}) - ${this.autoSaves.length}/${this.maxAutoSaves}`);\r\n  }\r\n  \r\n  // List all saves\r\n  listSaves() {\r\n    console.log(`\ud83d\udcda Save Manager - All Saves:`);\r\n    \r\n    // Named saves\r\n    if (this.saveSlots.size > 0) {\r\n      console.log(`\\n   Named Saves (${this.saveSlots.size}):`);\r\n      for (const [name, memento] of this.saveSlots) {\r\n        const info = memento.getSaveInfo();\r\n        console.log(`     ${name}: Level ${info.playerLevel} at ${info.location} (${memento.getTimestamp().toLocaleString()})`);\r\n      }\r\n    }\r\n    \r\n    // Quick saves\r\n    if (this.quickSaves.length > 0) {\r\n      console.log(`\\n   Quick Saves (${this.quickSaves.length}):`);\r\n      this.quickSaves.forEach((memento, index) => {\r\n        const info = memento.getSaveInfo();\r\n        console.log(`     ${index + 1}: Level ${info.playerLevel} at ${info.location} (${memento.getTimestamp().toLocaleString()})`);\r\n      });\r\n    }\r\n    \r\n    // Auto saves\r\n    if (this.autoSaves.length > 0) {\r\n      console.log(`\\n   Auto Saves (${this.autoSaves.length}):`);\r\n      this.autoSaves.forEach((save, index) => {\r\n        const info = save.memento.getSaveInfo();\r\n        console.log(`     ${index + 1}: ${save.trigger} - Level ${info.playerLevel} (${save.timestamp.toLocaleString()})`);\r\n      });\r\n    }\r\n  }\r\n  \r\n  deleteSave(slotName) {\r\n    if (this.saveSlots.has(slotName)) {\r\n      this.saveSlots.delete(slotName);\r\n      console.log(`\ud83d\uddd1\ufe0f Deleted save: ${slotName}`);\r\n      return true;\r\n    } else {\r\n      console.log(`\u274c Save not found: ${slotName}`);\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\n// Usage\r\nconsole.log("\\n=== Game Save System Demo ===\\n");\r\n\r\nconsole.log("Starting new game:");\r\nconsole.log("-".repeat(18));\r\n\r\nconst game = new GameEngine();\r\nconst saveManager = new SaveManager();\r\n\r\ngame.getGameStatus();\r\n\r\nconsole.log("\\n" + "=".repeat(50) + "\\n");\r\n\r\nconsole.log("Playing the game:");\r\nconsole.log("-".repeat(17));\r\n\r\n// Simulate gameplay\r\ngame.moveToLocation(\'Forest Path\');\r\nsaveManager.autoSave(game, \'location-change\');\r\n\r\ngame.gainExperience(30);\r\ngame.addToInventory({ name: \'Iron Sword\', type: \'weapon\', damage: 20 });\r\n\r\ngame.moveToLocation(\'Ancient Cave\');\r\ngame.completeQuest(\'Explore the Cave\');\r\nsaveManager.quickSave(game);\r\n\r\ngame.gainExperience(40);\r\ngame.addToInventory({ name: \'Magic Potion\', type: \'consumable\', quantity: 2 });\r\n\r\n// Manual save\r\nsaveManager.save(game, \'Before Boss Fight\');\r\n\r\nconsole.log("\\n" + "=".repeat(50) + "\\n");\r\n\r\nconsole.log("Current game state:");\r\nconsole.log("-".repeat(20));\r\n\r\ngame.getGameStatus();\r\n\r\nconsole.log("\\n" + "=".repeat(50) + "\\n");\r\n\r\nconsole.log("Save system overview:");\r\nconsole.log("-".repeat(22));\r\n\r\nsaveManager.listSaves();\r\n\r\nconsole.log("\\n" + "=".repeat(50) + "\\n");\r\n\r\nconsole.log("Simulating game over and reload:");\r\nconsole.log("-".repeat(35));\r\n\r\n// Continue playing (simulate boss fight loss)\r\nconsole.log("\ud83d\ude35 Player died in boss fight!");\r\nconsole.log("\ud83d\udc80 Game Over\\n");\r\n\r\n// Load from previous save\r\nconsole.log("Loading previous save...");\r\nsaveManager.load(game, \'Before Boss Fight\');\r\n\r\nconsole.log("\\nGame state after reload:");\r\nconsole.log("-".repeat(25));\r\ngame.getGameStatus();\n'})}),"\n",(0,o.jsx)(n.h2,{id:"-pros",children:"\u2705 Pros"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Encapsulation"}),": Preserves object encapsulation while allowing state access"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Undo/Redo"}),": Enables undo/redo functionality easily"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"State Snapshots"}),": Can create multiple snapshots at different points"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Time Travel"}),": Can restore object to any previous state"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Rollback"}),": Easy rollback on errors or failures"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"-cons",children:"\u274c Cons"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Memory Usage"}),": Storing multiple states can consume significant memory"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Performance"}),": Creating and storing mementos has overhead"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Large Objects"}),": Expensive for objects with large state"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Deep Copy Issues"}),": Complex objects may require deep copying"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"-when-to-use",children:"\ud83c\udfaf When to Use"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Undo/Redo"}),": Need to implement undo/redo functionality"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Snapshots"}),": Want to create checkpoints or snapshots"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Rollback"}),": Need rollback capability for transactions"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"State History"}),": Need to maintain history of state changes"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Error Recovery"}),": Want to restore state after errors"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"-memento-variations",children:"\ud83d\udd04 Memento Variations"}),"\n",(0,o.jsxs)(n.h3,{id:"1-command-based-memento",children:["1. ",(0,o.jsx)(n.strong,{children:"Command-based Memento"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"class CommandMemento {\r\n  constructor(command) {\r\n    this.command = command;\r\n    this.timestamp = new Date();\r\n  }\r\n  \r\n  undo() {\r\n    return this.command.undo();\r\n  }\r\n}\n"})}),"\n",(0,o.jsxs)(n.h3,{id:"2-incremental-memento",children:["2. ",(0,o.jsx)(n.strong,{children:"Incremental Memento"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"class IncrementalMemento {\r\n  constructor(changes) {\r\n    this.changes = changes; // Only store what changed\r\n    this.timestamp = new Date();\r\n  }\r\n  \r\n  apply(object) {\r\n    Object.assign(object, this.changes);\r\n  }\r\n}\n"})}),"\n",(0,o.jsxs)(n.h3,{id:"3-compressed-memento",children:["3. ",(0,o.jsx)(n.strong,{children:"Compressed Memento"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"class CompressedMemento {\r\n  constructor(state) {\r\n    this.compressedState = this.compress(state);\r\n    this.timestamp = new Date();\r\n  }\r\n  \r\n  compress(state) {\r\n    return JSON.stringify(state); // Could use actual compression\r\n  }\r\n  \r\n  decompress() {\r\n    return JSON.parse(this.compressedState);\r\n  }\r\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"-related-patterns",children:"\ud83d\udd17 Related Patterns"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Command"}),": Both can implement undo, but Command undoes operations while Memento restores state"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Iterator"}),": Can be used to traverse memento history"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Prototype"}),": Can use cloning to create mementos"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Caretaker Pattern"}),": Often used together to manage mementos"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"-further-reading",children:"\ud83d\udcda Further Reading"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://refactoring.guru/design-patterns/memento",children:"Memento Pattern - Refactoring.Guru"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Design_Patterns",children:"Gang of Four Design Patterns"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/structuredClone",children:"JavaScript Object Cloning for State Management"})}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var r=t(6540);const o={},s=r.createContext(o);function i(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);