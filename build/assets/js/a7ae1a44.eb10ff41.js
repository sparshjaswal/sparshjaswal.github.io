"use strict";(globalThis.webpackChunka=globalThis.webpackChunka||[]).push([[9843],{6565:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"dsa-key-pattern/Depth-First-Search","title":"Depth First Search (DFS)","description":"Description","source":"@site/docs/dsa-key-pattern/10-Depth-First-Search.md","sourceDirName":"dsa-key-pattern","slug":"/dsa-key-pattern/Depth-First-Search","permalink":"/docs/dsa-key-pattern/Depth-First-Search","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":10,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Breadth First Search (BFS)","permalink":"/docs/dsa-key-pattern/Breadth-First-Search"},"next":{"title":"Backtracking","permalink":"/docs/dsa-key-pattern/Backtracking"}}');var s=i(4848),l=i(8453);const t={},c="Depth First Search (DFS)",a={},d=[{value:"Description",id:"description",level:2},{value:"Time Complexity",id:"time-complexity",level:2},{value:"Space Complexity",id:"space-complexity",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Key Problems",id:"key-problems",level:2},{value:"When to Use",id:"when-to-use",level:2},{value:"Pattern Recognition",id:"pattern-recognition",level:2},{value:"DFS Variants",id:"dfs-variants",level:2},{value:"Standard DFS",id:"standard-dfs",level:3},{value:"DFS with Path Tracking",id:"dfs-with-path-tracking",level:3},{value:"DFS from Boundary",id:"dfs-from-boundary",level:3},{value:"Cycle Detection DFS",id:"cycle-detection-dfs",level:3},{value:"Implementation Approaches",id:"implementation-approaches",level:2},{value:"Recursive DFS",id:"recursive-dfs",level:3},{value:"Iterative DFS",id:"iterative-dfs",level:3},{value:"DFS with Backtracking",id:"dfs-with-backtracking",level:3}];function o(e){const n={h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"depth-first-search-dfs",children:"Depth First Search (DFS)"})}),"\n",(0,s.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,s.jsx)(n.p,{children:"DFS explores as far as possible along a branch before backtracking. It's useful for graph traversal, pathfinding, and connected components."}),"\n",(0,s.jsx)(n.h2,{id:"time-complexity",children:"Time Complexity"}),"\n",(0,s.jsx)(n.p,{children:"O(V + E) where V is vertices and E is edges"}),"\n",(0,s.jsx)(n.h2,{id:"space-complexity",children:"Space Complexity"}),"\n",(0,s.jsx)(n.p,{children:"O(V) for the recursion stack"}),"\n",(0,s.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Deep Exploration"}),": Go as far as possible before backtracking"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Recursive/Stack-Based"}),": Can be implemented recursively or with explicit stack"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Path Finding"}),": Explore all possible paths"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Connected Components"}),": Find all nodes in a component"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"key-problems",children:"Key Problems"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Number of Closed Islands"}),"\n",(0,s.jsx)(n.li,{children:"Coloring a Border"}),"\n",(0,s.jsx)(n.li,{children:"DFS from boundary: Number of Enclaves"}),"\n",(0,s.jsx)(n.li,{children:"Shortest time: Time Needed to Inform all Employees"}),"\n",(0,s.jsx)(n.li,{children:"Cyclic Find: Find Eventual Safe States"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"when-to-use",children:"When to Use"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Finding connected components"}),"\n",(0,s.jsx)(n.li,{children:"Detecting cycles in graphs"}),"\n",(0,s.jsx)(n.li,{children:"Path existence problems"}),"\n",(0,s.jsx)(n.li,{children:"Topological sorting preparation"}),"\n",(0,s.jsx)(n.li,{children:"Tree/graph traversal when order doesn't matter"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"pattern-recognition",children:"Pattern Recognition"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'"Find all connected components"'}),"\n",(0,s.jsx)(n.li,{children:'"Detect cycle in graph"'}),"\n",(0,s.jsx)(n.li,{children:'"Explore all possible paths"'}),"\n",(0,s.jsx)(n.li,{children:'"Mark visited regions"'}),"\n",(0,s.jsx)(n.li,{children:'"Tree traversal problems"'}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"dfs-variants",children:"DFS Variants"}),"\n",(0,s.jsx)(n.h3,{id:"standard-dfs",children:"Standard DFS"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Mark visited, explore all neighbors recursively"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"dfs-with-path-tracking",children:"DFS with Path Tracking"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Keep track of current path for backtracking problems"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"dfs-from-boundary",children:"DFS from Boundary"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Start DFS from boundary cells/nodes"}),"\n",(0,s.jsx)(n.li,{children:"Mark all reachable nodes"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"cycle-detection-dfs",children:"Cycle Detection DFS"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use three colors: white (unvisited), gray (processing), black (finished)"}),"\n",(0,s.jsx)(n.li,{children:"Gray node reached again = cycle found"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"implementation-approaches",children:"Implementation Approaches"}),"\n",(0,s.jsx)(n.h3,{id:"recursive-dfs",children:"Recursive DFS"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Clean and intuitive"}),"\n",(0,s.jsx)(n.li,{children:"Uses call stack implicitly"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"iterative-dfs",children:"Iterative DFS"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use explicit stack"}),"\n",(0,s.jsx)(n.li,{children:"Better control over memory usage"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"dfs-with-backtracking",children:"DFS with Backtracking"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Undo changes when backtracking"}),"\n",(0,s.jsx)(n.li,{children:"Used in path-finding problems"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>c});var r=i(6540);const s={},l=r.createContext(s);function t(e){const n=r.useContext(l);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),r.createElement(l.Provider,{value:n},e.children)}}}]);