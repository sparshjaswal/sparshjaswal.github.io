"use strict";(globalThis.webpackChunka=globalThis.webpackChunka||[]).push([[4199],{761:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"functional-programming/functor-functions/README","title":"\ud83c\udfad Functor Functions & Mappable Structures","description":"Understanding functors: containers that can be mapped over while preserving structure","source":"@site/docs/functional-programming/functor-functions/README.md","sourceDirName":"functional-programming/functor-functions","slug":"/functional-programming/functor-functions/","permalink":"/docs/functional-programming/functor-functions/","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"\ud83d\udd04 Function Composition & Higher-Order Functions","permalink":"/docs/functional-programming/function-and-composition/"},"next":{"title":"\ud83c\udfd7\ufe0f Monads: Advanced Functional Patterns","permalink":"/docs/functional-programming/monads/"}}');var i=t(4848),a=t(8453);const o={},s="\ud83c\udfad Functor Functions & Mappable Structures",l={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"What is a Functor?",id:"what-is-a-functor",level:2},{value:"Mathematical Definition",id:"mathematical-definition",level:3},{value:"Basic Functor Interface",id:"basic-functor-interface",level:3},{value:"Why Functors Matter",id:"why-functors-matter",level:3},{value:"Functor Laws",id:"functor-laws",level:2},{value:"1. Identity Law",id:"1-identity-law",level:3},{value:"2. Composition Law",id:"2-composition-law",level:3},{value:"Verifying Functor Laws",id:"verifying-functor-laws",level:3},{value:"Built-in JavaScript Functors",id:"built-in-javascript-functors",level:2},{value:"Array as a Functor",id:"array-as-a-functor",level:3},{value:"Promise as a Functor",id:"promise-as-a-functor",level:3},{value:"Function as a Functor",id:"function-as-a-functor",level:3},{value:"Creating Custom Functors",id:"creating-custom-functors",level:2},{value:"Container Functor",id:"container-functor",level:3},{value:"Box Functor with Debugging",id:"box-functor-with-debugging",level:3},{value:"Maybe Functor",id:"maybe-functor",level:2},{value:"Basic Maybe Implementation",id:"basic-maybe-implementation",level:3},{value:"Maybe with Real-World Examples",id:"maybe-with-real-world-examples",level:3},{value:"Either Functor",id:"either-functor",level:2},{value:"Either Implementation",id:"either-implementation",level:3},{value:"Either for Validation",id:"either-for-validation",level:3},{value:"IO Functor",id:"io-functor",level:2},{value:"IO Implementation",id:"io-implementation",level:3},{value:"Pointed Functors",id:"pointed-functors",level:2},{value:"Pointed Functor Interface",id:"pointed-functor-interface",level:3},{value:"Applicative Functor Pattern",id:"applicative-functor-pattern",level:3},{value:"Real-World Applications",id:"real-world-applications",level:2},{value:"Safe DOM Manipulation",id:"safe-dom-manipulation",level:3},{value:"Async Operations with Promise Functors",id:"async-operations-with-promise-functors",level:3},{value:"Configuration Pipeline",id:"configuration-pipeline",level:3},{value:"Advanced Functor Patterns",id:"advanced-functor-patterns",level:2},{value:"Functor Composition",id:"functor-composition",level:3},{value:"Functor Transformers",id:"functor-transformers",level:3},{value:"Covariant and Contravariant Functors",id:"covariant-and-contravariant-functors",level:3},{value:"\ud83c\udfaf Key Takeaways",id:"-key-takeaways",level:2}];function u(n){const e={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"-functor-functions--mappable-structures",children:"\ud83c\udfad Functor Functions & Mappable Structures"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.em,{children:"Understanding functors: containers that can be mapped over while preserving structure"})}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#what-is-a-functor",children:"What is a Functor?"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#functor-laws",children:"Functor Laws"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#built-in-javascript-functors",children:"Built-in JavaScript Functors"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#creating-custom-functors",children:"Creating Custom Functors"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#maybe-functor",children:"Maybe Functor"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#either-functor",children:"Either Functor"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#io-functor",children:"IO Functor"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pointed-functors",children:"Pointed Functors"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#real-world-applications",children:"Real-World Applications"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#advanced-functor-patterns",children:"Advanced Functor Patterns"})}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"what-is-a-functor",children:"What is a Functor?"}),"\n",(0,i.jsxs)(e.p,{children:["A ",(0,i.jsx)(e.strong,{children:"functor"})," is a type that implements a ",(0,i.jsx)(e.code,{children:"map"}),' method which applies a function to the wrapped value(s) while preserving the container\'s structure. Think of it as a "mappable" container.']}),"\n",(0,i.jsx)(e.h3,{id:"mathematical-definition",children:"Mathematical Definition"}),"\n",(0,i.jsxs)(e.p,{children:["In category theory, a functor ",(0,i.jsx)(e.code,{children:"F"})," must satisfy:"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"F.map(id) = id"})," (Identity law)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"F.map(compose(f, g)) = compose(F.map(f), F.map(g))"})," (Composition law)"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"basic-functor-interface",children:"Basic Functor Interface"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:'// Generic functor interface\nclass Functor {\n    constructor(value) {\n        this.value = value;\n    }\n    \n    // The map method is what makes it a functor\n    map(fn) {\n        return new Functor(fn(this.value));\n    }\n    \n    // Static constructor (pointed functor)\n    static of(value) {\n        return new Functor(value);\n    }\n}\n\n// Usage\nconst result = Functor.of(5)\n    .map(x => x * 2)\n    .map(x => x + 1)\n    .map(x => `Result: ${x}`);\n\nconsole.log(result.value); // "Result: 11"\n'})}),"\n",(0,i.jsx)(e.h3,{id:"why-functors-matter",children:"Why Functors Matter"}),"\n",(0,i.jsx)(e.p,{children:"Functors provide a consistent way to:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Apply transformations"})," without unwrapping values"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Chain operations"})," safely"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Handle context"})," (null values, errors, async operations)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Maintain structure"})," while transforming content"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"functor-laws",children:"Functor Laws"}),"\n",(0,i.jsx)(e.p,{children:"All functors must obey two fundamental laws:"}),"\n",(0,i.jsx)(e.h3,{id:"1-identity-law",children:"1. Identity Law"}),"\n",(0,i.jsx)(e.p,{children:"Mapping the identity function should return the original functor."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"const identity = x => x;\n\n// Law: functor.map(identity) === functor\nconst original = Functor.of(42);\nconst mapped = original.map(identity);\n\nconsole.log(original.value === mapped.value); // true\n"})}),"\n",(0,i.jsx)(e.h3,{id:"2-composition-law",children:"2. Composition Law"}),"\n",(0,i.jsx)(e.p,{children:"Mapping a composition should equal composing the maps."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"const compose = (f, g) => x => f(g(x));\nconst addOne = x => x + 1;\nconst double = x => x * 2;\n\nconst functor = Functor.of(5);\n\n// These should be equivalent:\nconst composed = functor.map(compose(double, addOne));\nconst chained = functor.map(addOne).map(double);\n\nconsole.log(composed.value === chained.value); // true\n"})}),"\n",(0,i.jsx)(e.h3,{id:"verifying-functor-laws",children:"Verifying Functor Laws"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Law verification utility\nconst verifyFunctorLaws = (FunctorType, value, f, g) => {\n    const functor = FunctorType.of(value);\n    const identity = x => x;\n    const compose = (fn1, fn2) => x => fn1(fn2(x));\n    \n    // Identity law\n    const identityTest = functor.map(identity).value === functor.value;\n    \n    // Composition law  \n    const composed = functor.map(compose(f, g));\n    const chained = functor.map(g).map(f);\n    const compositionTest = composed.value === chained.value;\n    \n    return {\n        identity: identityTest,\n        composition: compositionTest,\n        valid: identityTest && compositionTest\n    };\n};\n\n// Test our Functor\nconst result = verifyFunctorLaws(\n    Functor,\n    10,\n    x => x * 2,\n    x => x + 5\n);\nconsole.log(result); // { identity: true, composition: true, valid: true }\n"})}),"\n",(0,i.jsx)(e.h2,{id:"built-in-javascript-functors",children:"Built-in JavaScript Functors"}),"\n",(0,i.jsx)(e.p,{children:"JavaScript has several built-in functors that you use every day:"}),"\n",(0,i.jsx)(e.h3,{id:"array-as-a-functor",children:"Array as a Functor"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:'// \u2705 Arrays are functors\nconst numbers = [1, 2, 3, 4, 5];\n\nconst result = numbers\n    .map(x => x * 2)        // [2, 4, 6, 8, 10]\n    .map(x => x + 1)        // [3, 5, 7, 9, 11]\n    .map(x => `${x}!`);     // ["3!", "5!", "7!", "9!", "11!"]\n\nconsole.log(result);\n\n// Arrays preserve structure and apply function to each element\nconst nested = [[1, 2], [3, 4], [5, 6]];\nconst flattened = nested.map(arr => arr.map(x => x * 2));\nconsole.log(flattened); // [[2, 4], [6, 8], [10, 12]]\n'})}),"\n",(0,i.jsx)(e.h3,{id:"promise-as-a-functor",children:"Promise as a Functor"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:'// \u2705 Promises are functors\nconst asyncValue = Promise.resolve(42);\n\nconst result = asyncValue\n    .then(x => x * 2)       // Still a Promise\n    .then(x => x + 8)       // Still a Promise\n    .then(x => `${x}!`);    // Still a Promise\n\nresult.then(console.log); // "92!"\n\n// Promises preserve the async context while transforming the value\n'})}),"\n",(0,i.jsx)(e.h3,{id:"function-as-a-functor",children:"Function as a Functor"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Functions can be functors (function composition)\nconst addTen = x => x + 10;\nconst multiplyByTwo = x => x * 2;\n\n// Function composition is like mapping over functions\nconst composedFunction = (value) => multiplyByTwo(addTen(value));\n\nconsole.log(composedFunction(5)); // 30\n\n// More explicit functor-like interface for functions\nclass FunctionFunctor {\n    constructor(fn) {\n        this.fn = fn;\n    }\n    \n    map(g) {\n        return new FunctionFunctor(x => g(this.fn(x)));\n    }\n    \n    run(input) {\n        return this.fn(input);\n    }\n    \n    static of(fn) {\n        return new FunctionFunctor(fn);\n    }\n}\n\nconst pipeline = FunctionFunctor.of(x => x + 5)\n    .map(x => x * 2)\n    .map(x => x - 3);\n\nconsole.log(pipeline.run(10)); // ((10 + 5) * 2) - 3 = 27\n"})}),"\n",(0,i.jsx)(e.h2,{id:"creating-custom-functors",children:"Creating Custom Functors"}),"\n",(0,i.jsx)(e.h3,{id:"container-functor",children:"Container Functor"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Basic container functor\nclass Container {\n    constructor(value) {\n        this.value = value;\n    }\n    \n    map(fn) {\n        return Container.of(fn(this.value));\n    }\n    \n    static of(value) {\n        return new Container(value);\n    }\n    \n    // Utility method for debugging\n    inspect() {\n        return `Container(${this.value})`;\n    }\n}\n\n// Usage\nconst container = Container.of(\"Hello World\")\n    .map(s => s.toUpperCase())\n    .map(s => s.split(' '))\n    .map(arr => arr.reverse())\n    .map(arr => arr.join(' '));\n\nconsole.log(container.inspect()); // Container(WORLD HELLO)\n"})}),"\n",(0,i.jsx)(e.h3,{id:"box-functor-with-debugging",children:"Box Functor with Debugging"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Box functor with enhanced debugging\nclass Box {\n    constructor(value) {\n        this.value = value;\n        this.history = [];\n    }\n    \n    map(fn, description = 'transform') {\n        const newValue = fn(this.value);\n        const newBox = Box.of(newValue);\n        newBox.history = [\n            ...this.history,\n            {\n                operation: description,\n                from: this.value,\n                to: newValue,\n                function: fn.toString()\n            }\n        ];\n        return newBox;\n    }\n    \n    static of(value) {\n        return new Box(value);\n    }\n    \n    fold(fn) {\n        return fn(this.value);\n    }\n    \n    inspect() {\n        return `Box(${JSON.stringify(this.value)})`;\n    }\n    \n    trace() {\n        console.log('Transformation history:');\n        this.history.forEach((step, i) => {\n            console.log(`${i + 1}. ${step.operation}: ${step.from} -> ${step.to}`);\n        });\n        return this;\n    }\n}\n\n// Usage with tracing\nconst result = Box.of(10)\n    .map(x => x + 5, 'add 5')\n    .map(x => x * 2, 'multiply by 2')\n    .map(x => x - 3, 'subtract 3')\n    .trace()\n    .fold(x => `Final: ${x}`);\n\nconsole.log(result); // \"Final: 27\"\n"})}),"\n",(0,i.jsx)(e.h2,{id:"maybe-functor",children:"Maybe Functor"}),"\n",(0,i.jsx)(e.p,{children:"The Maybe functor handles null/undefined values gracefully, preventing null pointer exceptions."}),"\n",(0,i.jsx)(e.h3,{id:"basic-maybe-implementation",children:"Basic Maybe Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Maybe functor for null safety\nclass Maybe {\n    constructor(value) {\n        this.value = value;\n    }\n    \n    isNothing() {\n        return this.value === null || this.value === undefined;\n    }\n    \n    isSomething() {\n        return !this.isNothing();\n    }\n    \n    map(fn) {\n        return this.isNothing() ? Maybe.nothing() : Maybe.of(fn(this.value));\n    }\n    \n    flatMap(fn) {\n        return this.isNothing() ? Maybe.nothing() : fn(this.value);\n    }\n    \n    getOrElse(defaultValue) {\n        return this.isNothing() ? defaultValue : this.value;\n    }\n    \n    filter(predicate) {\n        return this.isNothing() || predicate(this.value) \n            ? this \n            : Maybe.nothing();\n    }\n    \n    static of(value) {\n        return new Maybe(value);\n    }\n    \n    static nothing() {\n        return new Maybe(null);\n    }\n    \n    static some(value) {\n        return value === null || value === undefined \n            ? Maybe.nothing() \n            : Maybe.of(value);\n    }\n    \n    inspect() {\n        return this.isNothing() \n            ? 'Maybe.Nothing' \n            : `Maybe.Some(${this.value})`;\n    }\n}\n\n// Usage examples\nconst safeDiv = (a, b) => b === 0 ? Maybe.nothing() : Maybe.of(a / b);\n\nconst result1 = Maybe.of(20)\n    .flatMap(x => safeDiv(x, 2))\n    .map(x => x + 5)\n    .map(x => `Result: ${x}`)\n    .getOrElse('Error: Division by zero');\n\nconsole.log(result1); // \"Result: 15\"\n\nconst result2 = Maybe.of(20)\n    .flatMap(x => safeDiv(x, 0))  // Returns Maybe.nothing()\n    .map(x => x + 5)              // Skipped\n    .map(x => `Result: ${x}`)     // Skipped\n    .getOrElse('Error: Division by zero');\n\nconsole.log(result2); // \"Error: Division by zero\"\n"})}),"\n",(0,i.jsx)(e.h3,{id:"maybe-with-real-world-examples",children:"Maybe with Real-World Examples"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Real-world Maybe usage\nconst users = [\n    { id: 1, name: 'John', address: { street: '123 Main St', city: 'Boston' } },\n    { id: 2, name: 'Jane', address: null },\n    { id: 3, name: 'Bob' }\n];\n\n// Safe property access\nconst getUserCity = (user) => \n    Maybe.of(user)\n        .map(u => u.address)\n        .map(addr => addr.city)\n        .getOrElse('Unknown City');\n\nusers.forEach(user => {\n    console.log(`${user.name} lives in: ${getUserCity(user)}`);\n});\n// John lives in: Boston\n// Jane lives in: Unknown City  \n// Bob lives in: Unknown City\n\n// Safe API response handling\nconst processApiResponse = (response) => \n    Maybe.of(response)\n        .filter(r => r.success)\n        .map(r => r.data)\n        .map(data => data.users)\n        .map(users => users.filter(u => u.active))\n        .getOrElse([]);\n\nconst apiResponse1 = { success: true, data: { users: [{ active: true, name: 'Alice' }] } };\nconst apiResponse2 = { success: false, error: 'Server error' };\n\nconsole.log(processApiResponse(apiResponse1)); // [{ active: true, name: 'Alice' }]\nconsole.log(processApiResponse(apiResponse2)); // []\n"})}),"\n",(0,i.jsx)(e.h2,{id:"either-functor",children:"Either Functor"}),"\n",(0,i.jsx)(e.p,{children:"The Either functor handles computations that might fail, representing either a success (Right) or failure (Left)."}),"\n",(0,i.jsx)(e.h3,{id:"either-implementation",children:"Either Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:'// \u2705 Either functor for error handling\nclass Either {\n    constructor(value, isRight = true) {\n        this.value = value;\n        this.isRight = isRight;\n    }\n    \n    isLeft() {\n        return !this.isRight;\n    }\n    \n    map(fn) {\n        return this.isLeft() ? this : Either.right(fn(this.value));\n    }\n    \n    mapLeft(fn) {\n        return this.isLeft() ? Either.left(fn(this.value)) : this;\n    }\n    \n    flatMap(fn) {\n        return this.isLeft() ? this : fn(this.value);\n    }\n    \n    fold(leftFn, rightFn) {\n        return this.isLeft() ? leftFn(this.value) : rightFn(this.value);\n    }\n    \n    getOrElse(defaultValue) {\n        return this.isLeft() ? defaultValue : this.value;\n    }\n    \n    static left(value) {\n        return new Either(value, false);\n    }\n    \n    static right(value) {\n        return new Either(value, true);\n    }\n    \n    static of(value) {\n        return Either.right(value);\n    }\n    \n    static try(fn) {\n        try {\n            return Either.right(fn());\n        } catch (error) {\n            return Either.left(error.message);\n        }\n    }\n    \n    inspect() {\n        return this.isLeft() \n            ? `Either.Left(${this.value})` \n            : `Either.Right(${this.value})`;\n    }\n}\n\n// Usage examples\nconst parseJSON = (str) => Either.try(() => JSON.parse(str));\n\nconst processData = (jsonString) =>\n    parseJSON(jsonString)\n        .map(obj => obj.user)\n        .map(user => user.name)\n        .map(name => name.toUpperCase())\n        .map(name => `Hello, ${name}!`)\n        .fold(\n            error => `Error: ${error}`,\n            result => result\n        );\n\nconsole.log(processData(\'{"user":{"name":"alice"}}\')); // "Hello, ALICE!"\nconsole.log(processData(\'invalid json\'));               // "Error: Unexpected token..."\n'})}),"\n",(0,i.jsx)(e.h3,{id:"either-for-validation",children:"Either for Validation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Either for validation chains\nconst validateEmail = (email) => {\n    if (!email) return Either.left('Email is required');\n    if (!email.includes('@')) return Either.left('Email must contain @');\n    if (email.length < 5) return Either.left('Email too short');\n    return Either.right(email);\n};\n\nconst validateAge = (age) => {\n    if (age === undefined) return Either.left('Age is required');\n    if (age < 0) return Either.left('Age must be positive');\n    if (age > 150) return Either.left('Age must be realistic');\n    return Either.right(age);\n};\n\nconst createUser = (email, age) => \n    validateEmail(email)\n        .flatMap(validEmail => \n            validateAge(age).map(validAge => ({\n                email: validEmail,\n                age: validAge,\n                id: Math.random()\n            }))\n        );\n\n// Test validation\nconsole.log(createUser('john@example.com', 25)); // Either.Right({...})\nconsole.log(createUser('invalid', 25));          // Either.Left('Email must contain @')\nconsole.log(createUser('john@example.com', -5)); // Either.Left('Age must be positive')\n"})}),"\n",(0,i.jsx)(e.h2,{id:"io-functor",children:"IO Functor"}),"\n",(0,i.jsx)(e.p,{children:"The IO functor wraps side-effectful operations, allowing you to compose them while deferring execution."}),"\n",(0,i.jsx)(e.h3,{id:"io-implementation",children:"IO Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 IO functor for side effects\nclass IO {\n    constructor(effect) {\n        this.effect = effect;\n    }\n    \n    map(fn) {\n        return new IO(() => fn(this.effect()));\n    }\n    \n    flatMap(fn) {\n        return new IO(() => fn(this.effect()).effect());\n    }\n    \n    run() {\n        return this.effect();\n    }\n    \n    static of(value) {\n        return new IO(() => value);\n    }\n    \n    static from(effect) {\n        return new IO(effect);\n    }\n}\n\n// Side-effect functions wrapped in IO\nconst readFile = (filename) => IO.from(() => {\n    console.log(`Reading file: ${filename}`);\n    return `Contents of ${filename}`;\n});\n\nconst writeFile = (filename, content) => IO.from(() => {\n    console.log(`Writing to file: ${filename}`);\n    console.log(`Content: ${content}`);\n    return `Written to ${filename}`;\n});\n\nconst log = (message) => IO.from(() => {\n    console.log(`LOG: ${message}`);\n    return message;\n});\n\n// Compose IO operations without executing them\nconst fileOperation = readFile('input.txt')\n    .map(content => content.toUpperCase())\n    .flatMap(content => log(`Processing: ${content.slice(0, 20)}...`))\n    .map(content => content + '\\n\\nProcessed by IO Functor')\n    .flatMap(content => writeFile('output.txt', content));\n\n// Execute the composed operation\nconsole.log('About to run IO operations...');\nconst result = fileOperation.run();\nconsole.log('Final result:', result);\n"})}),"\n",(0,i.jsx)(e.h2,{id:"pointed-functors",children:"Pointed Functors"}),"\n",(0,i.jsxs)(e.p,{children:["A pointed functor is a functor with an ",(0,i.jsx)(e.code,{children:"of"})," method (also called ",(0,i.jsx)(e.code,{children:"pure"})," or ",(0,i.jsx)(e.code,{children:"return"}),") that can lift a value into the functor context."]}),"\n",(0,i.jsx)(e.h3,{id:"pointed-functor-interface",children:"Pointed Functor Interface"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Generic pointed functor\nclass Pointed {\n    constructor(value) {\n        this.value = value;\n    }\n    \n    map(fn) {\n        return Pointed.of(fn(this.value));\n    }\n    \n    // The 'of' method makes it a pointed functor\n    static of(value) {\n        return new Pointed(value);\n    }\n    \n    // Additional utility methods\n    flatMap(fn) {\n        return fn(this.value);\n    }\n    \n    apply(functor) {\n        return functor.map(this.value);\n    }\n}\n\n// All the functors we've seen are pointed functors\nconsole.log(Container.of);     // Function\nconsole.log(Maybe.of);         // Function  \nconsole.log(Either.of);        // Function\nconsole.log(IO.of);            // Function\n"})}),"\n",(0,i.jsx)(e.h3,{id:"applicative-functor-pattern",children:"Applicative Functor Pattern"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Applicative functor for multi-argument functions\nclass Applicative {\n    constructor(value) {\n        this.value = value;\n    }\n    \n    map(fn) {\n        return Applicative.of(fn(this.value));\n    }\n    \n    apply(functor) {\n        return functor.map(this.value);\n    }\n    \n    static of(value) {\n        return new Applicative(value);\n    }\n}\n\n// Lift multi-argument functions\nconst add = (a) => (b) => (c) => a + b + c;\n\nconst result = Applicative.of(add)\n    .apply(Applicative.of(1))\n    .apply(Applicative.of(2))\n    .apply(Applicative.of(3));\n\nconsole.log(result.value); // 6\n\n// More practical example with validation\nconst validateAndCreate = (name) => (email) => (age) => ({\n    name,\n    email,\n    age,\n    valid: true\n});\n\nconst user = Maybe.of(validateAndCreate)\n    .apply(Maybe.of('John'))\n    .apply(Maybe.of('john@example.com'))\n    .apply(Maybe.of(25));\n\nconsole.log(user.inspect()); // Maybe.Some({name: 'John', ...})\n"})}),"\n",(0,i.jsx)(e.h2,{id:"real-world-applications",children:"Real-World Applications"}),"\n",(0,i.jsx)(e.h3,{id:"safe-dom-manipulation",children:"Safe DOM Manipulation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Safe DOM operations with Maybe\nconst $ = (selector) => Maybe.of(document.querySelector(selector));\n\nconst updateUserProfile = (userId) => \n    $(`#user-${userId}`)\n        .map(element => element.querySelector('.name'))\n        .map(nameEl => nameEl.textContent)\n        .map(name => name.trim())\n        .filter(name => name.length > 0)\n        .map(name => `Welcome, ${name}!`)\n        .map(welcome => {\n            $(`#welcome-${userId}`)\n                .map(el => el.textContent = welcome);\n            return welcome;\n        })\n        .getOrElse('User not found');\n\n// Safe event handling\nconst handleClick = (selector, handler) =>\n    $(selector)\n        .map(element => element.addEventListener('click', handler))\n        .getOrElse(console.warn(`Element ${selector} not found`));\n"})}),"\n",(0,i.jsx)(e.h3,{id:"async-operations-with-promise-functors",children:"Async Operations with Promise Functors"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Promise as functor for async operations\nconst fetchUser = (id) => \n    fetch(`/api/users/${id}`)\n        .then(response => response.json());\n\nconst fetchUserPosts = (userId) =>\n    fetch(`/api/users/${userId}/posts`)\n        .then(response => response.json());\n\n// Compose async operations\nconst getUserWithPosts = (id) =>\n    fetchUser(id)\n        .then(user => \n            fetchUserPosts(id)\n                .then(posts => ({ ...user, posts }))\n        )\n        .then(userData => ({\n            ...userData,\n            summary: `${userData.name} has ${userData.posts.length} posts`\n        }))\n        .catch(error => ({ error: error.message }));\n\n// Usage\ngetUserWithPosts(123)\n    .then(result => console.log(result))\n    .catch(error => console.error(error));\n"})}),"\n",(0,i.jsx)(e.h3,{id:"configuration-pipeline",children:"Configuration Pipeline"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Configuration with Either functor\nconst loadConfig = () => Either.try(() => {\n    // Simulate config loading\n    return {\n        apiUrl: 'https://api.example.com',\n        timeout: 5000,\n        retries: 3\n    };\n});\n\nconst validateConfig = (config) => {\n    if (!config.apiUrl) return Either.left('API URL is required');\n    if (config.timeout < 1000) return Either.left('Timeout too low');\n    if (config.retries < 0) return Either.left('Retries cannot be negative');\n    return Either.right(config);\n};\n\nconst enrichConfig = (config) => Either.right({\n    ...config,\n    version: '1.0.0',\n    timestamp: new Date().toISOString()\n});\n\nconst initializeApp = () =>\n    loadConfig()\n        .flatMap(validateConfig)\n        .flatMap(enrichConfig)\n        .fold(\n            error => console.error(`Config error: ${error}`),\n            config => {\n                console.log('App initialized with config:', config);\n                return config;\n            }\n        );\n\ninitializeApp();\n"})}),"\n",(0,i.jsx)(e.h2,{id:"advanced-functor-patterns",children:"Advanced Functor Patterns"}),"\n",(0,i.jsx)(e.h3,{id:"functor-composition",children:"Functor Composition"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Compose functors\nconst compose = (F, G) => ({\n    of: (value) => F.of(G.of(value)),\n    map: (fn) => (functor) => F.map(G.map(fn))(functor)\n});\n\n// Compose Maybe and Array\nconst MaybeArray = compose(Maybe, Array);\n\nconst result = Maybe.of([1, 2, 3, 4])\n    .map(arr => arr.map(x => x * 2))\n    .map(arr => arr.filter(x => x > 4));\n\nconsole.log(result.inspect()); // Maybe.Some([6, 8])\n"})}),"\n",(0,i.jsx)(e.h3,{id:"functor-transformers",children:"Functor Transformers"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Functor transformer for nested contexts\nclass MaybeT {\n    constructor(innerFunctor) {\n        this.innerFunctor = innerFunctor;\n    }\n    \n    map(fn) {\n        return new MaybeT(\n            this.innerFunctor.map(maybe => maybe.map(fn))\n        );\n    }\n    \n    static lift(innerFunctor) {\n        return new MaybeT(innerFunctor.map(Maybe.of));\n    }\n    \n    run() {\n        return this.innerFunctor;\n    }\n}\n\n// Usage with Promise<Maybe<T>>\nconst asyncMaybe = MaybeT.lift(Promise.resolve(42));\nconst result = asyncMaybe\n    .map(x => x * 2)\n    .map(x => x + 10);\n\nresult.run()\n    .then(maybe => console.log(maybe.inspect())); // Maybe.Some(94)\n"})}),"\n",(0,i.jsx)(e.h3,{id:"covariant-and-contravariant-functors",children:"Covariant and Contravariant Functors"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Covariant functor (normal functor)\nclass Covariant {\n    constructor(value) {\n        this.value = value;\n    }\n    \n    map(fn) {\n        return new Covariant(fn(this.value));\n    }\n    \n    static of(value) {\n        return new Covariant(value);\n    }\n}\n\n// \u2705 Contravariant functor (transforms input, not output)\nclass Contravariant {\n    constructor(predicate) {\n        this.predicate = predicate;\n    }\n    \n    contramap(fn) {\n        return new Contravariant(value => this.predicate(fn(value)));\n    }\n    \n    test(value) {\n        return this.predicate(value);\n    }\n    \n    static of(predicate) {\n        return new Contravariant(predicate);\n    }\n}\n\n// Example: string length validator\nconst minLength = (min) => Contravariant.of(str => str.length >= min);\nconst emailValidator = minLength(5).contramap(email => email.trim());\n\nconsole.log(emailValidator.test('  test@example.com  ')); // true\nconsole.log(emailValidator.test('  a@b  ')); // false\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"-key-takeaways",children:"\ud83c\udfaf Key Takeaways"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Functors provide safe transformation"})," - apply functions without unwrapping values"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Obey functor laws"})," - identity and composition laws ensure predictable behavior"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"JavaScript has built-in functors"})," - Arrays, Promises, and Functions"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Maybe handles null values"})," - prevents null pointer exceptions elegantly"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Either handles errors"})," - functional error handling without exceptions"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"IO manages side effects"})," - compose effectful operations while deferring execution"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Pointed functors lift values"})," - the ",(0,i.jsx)(e.code,{children:"of"})," method brings values into functor context"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Composition is powerful"})," - combine functors for complex data transformations"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Functors are essential for functional programming, providing a consistent interface for transforming values while preserving structure and handling context."}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsxs)(e.em,{children:["Next: Learn about ",(0,i.jsx)(e.a,{href:"../Monads/",children:"Monads"})," to understand more powerful patterns for handling complex data flows."]}),"| functor Function\n\u201cFunctor is a plain object(or type of class in other languages) that implements the function map that, while running over each value in the object to produce a new object.\u201d\nA functor is nothing but a container that can hold the value,let\u2019s revisit the definition of a functor.\nFunctor needs to implement a method called map. Let\u2019s implement that method in the next section.\nA functor is a subset of functor, which has an interface that has contracts.\nMaybe Functor\nError handling using functional programming can be done using a functor which is through MayBe functor allows us to handle errors in our code in a more functional way.\nEither Functor\nEither will allow us to solve the branching-out problem.\nPointed Functor\nA functor is a subset of a functor which has an interface that has contracts."]})]})}function d(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(u,{...n})}):u(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>s});var r=t(6540);const i={},a=r.createContext(i);function o(n){const e=r.useContext(a);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:o(n.components),r.createElement(a.Provider,{value:e},n.children)}}}]);