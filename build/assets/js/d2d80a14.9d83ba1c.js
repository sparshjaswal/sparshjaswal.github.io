"use strict";(globalThis.webpackChunka=globalThis.webpackChunka||[]).push([[9355],{4646:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>i,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"design-pattern/behavioral/template-method","title":"Template Method Pattern \ud83d\udccb","description":"Definition: The Template Method pattern defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure.","source":"@site/docs/design-pattern/behavioral/template-method.md","sourceDirName":"design-pattern/behavioral","slug":"/design-pattern/behavioral/template-method","permalink":"/docs/design-pattern/behavioral/template-method","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Strategy Pattern \ud83c\udfaf","permalink":"/docs/design-pattern/behavioral/strategy"},"next":{"title":"Visitor Pattern \ud83c\udfc3\u200d\u2642\ufe0f","permalink":"/docs/design-pattern/behavioral/visitor"}}');var a=n(4848),o=n(8453);const s={},l="Template Method Pattern \ud83d\udccb",i={},c=[{value:"\ud83c\udfaf Intent",id:"-intent",level:2},{value:"\ud83e\udd14 Problem",id:"-problem",level:2},{value:"\ud83d\udca1 Solution",id:"-solution",level:2},{value:"\ud83c\udfd7\ufe0f Structure",id:"\ufe0f-structure",level:2},{value:"\ud83d\udcbb Simple Example",id:"-simple-example",level:2},{value:"Data Processing Pipeline",id:"data-processing-pipeline",level:3},{value:"\ud83c\udf1f Real-World Example",id:"-real-world-example",level:2},{value:"Game Level Generator",id:"game-level-generator",level:3},{value:"\u2705 Pros",id:"-pros",level:2},{value:"\u274c Cons",id:"-cons",level:2},{value:"\ud83c\udfaf When to Use",id:"-when-to-use",level:2},{value:"\ud83d\udd04 Template Method Variations",id:"-template-method-variations",level:2},{value:"1. <strong>Hook Methods</strong>",id:"1-hook-methods",level:3},{value:"2. <strong>Strategy-Template Hybrid</strong>",id:"2-strategy-template-hybrid",level:3},{value:"3. <strong>Functional Template Method</strong>",id:"3-functional-template-method",level:3},{value:"\ud83d\udd17 Related Patterns",id:"-related-patterns",level:2},{value:"\ud83d\udcda Further Reading",id:"-further-reading",level:2}];function d(e){const r={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(r.header,{children:(0,a.jsx)(r.h1,{id:"template-method-pattern-",children:"Template Method Pattern \ud83d\udccb"})}),"\n",(0,a.jsxs)(r.blockquote,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Definition"}),": The Template Method pattern defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure."]}),"\n"]}),"\n",(0,a.jsx)(r.h2,{id:"-intent",children:"\ud83c\udfaf Intent"}),"\n",(0,a.jsx)(r.p,{children:"Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure."}),"\n",(0,a.jsx)(r.h2,{id:"-problem",children:"\ud83e\udd14 Problem"}),"\n",(0,a.jsx)(r.p,{children:"You have several classes that perform similar operations with the same sequence of steps, but the implementation details differ:"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Code Duplication"}),": Similar algorithms with minor variations"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Algorithm Structure"}),": Want to ensure consistent algorithm structure"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Step Variations"}),": Some steps need different implementations"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Extension Points"}),": Need to allow customization at specific points"]}),"\n"]}),"\n",(0,a.jsx)(r.p,{children:"Without the pattern, you'd have to duplicate the entire algorithm in each class."}),"\n",(0,a.jsx)(r.h2,{id:"-solution",children:"\ud83d\udca1 Solution"}),"\n",(0,a.jsx)(r.p,{children:"The Template Method pattern suggests breaking down the algorithm into a series of steps and defining the overall structure in a base class. Subclasses can override specific steps while keeping the algorithm structure intact."}),"\n",(0,a.jsx)(r.h2,{id:"\ufe0f-structure",children:"\ud83c\udfd7\ufe0f Structure"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"AbstractClass\r\n\u251c\u2500\u2500 +templateMethod(): void \u2192 step1() + step2() + step3()\r\n\u251c\u2500\u2500 +step1(): void (concrete)\r\n\u251c\u2500\u2500 #step2(): void (abstract - must implement)\r\n\u251c\u2500\u2500 #step3(): void (hook - can override)\r\n\r\nConcreteClass1, ConcreteClass2 extend AbstractClass\r\n\u251c\u2500\u2500 +step2(): void (required implementation)\r\n\u251c\u2500\u2500 +step3(): void (optional override)\n"})}),"\n",(0,a.jsx)(r.h2,{id:"-simple-example",children:"\ud83d\udcbb Simple Example"}),"\n",(0,a.jsx)(r.h3,{id:"data-processing-pipeline",children:"Data Processing Pipeline"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// Abstract template class\r\nclass DataProcessor {\r\n  constructor() {\r\n    if (this.constructor === DataProcessor) {\r\n      throw new Error("DataProcessor is abstract and cannot be instantiated");\r\n    }\r\n  }\r\n  \r\n  // Template method - defines the algorithm structure\r\n  processData(inputData) {\r\n    console.log("\ud83d\udd04 Starting data processing pipeline...\\n");\r\n    \r\n    // Step 1: Validate data (concrete method)\r\n    if (!this.validateData(inputData)) {\r\n      console.log("\u274c Data validation failed");\r\n      return null;\r\n    }\r\n    \r\n    // Step 2: Extract data (abstract method - must be implemented)\r\n    const extractedData = this.extractData(inputData);\r\n    \r\n    // Step 3: Transform data (abstract method - must be implemented)\r\n    const transformedData = this.transformData(extractedData);\r\n    \r\n    // Step 4: Filter data (hook method - can be overridden)\r\n    const filteredData = this.filterData(transformedData);\r\n    \r\n    // Step 5: Save data (concrete method)\r\n    const result = this.saveData(filteredData);\r\n    \r\n    // Step 6: Generate report (hook method - can be overridden)\r\n    this.generateReport(result);\r\n    \r\n    console.log("\u2705 Data processing pipeline completed\\n");\r\n    return result;\r\n  }\r\n  \r\n  // Concrete method - same for all subclasses\r\n  validateData(inputData) {\r\n    console.log("\ud83d\udd0d Validating input data...");\r\n    \r\n    if (!inputData || inputData.length === 0) {\r\n      console.log("\u274c Input data is empty");\r\n      return false;\r\n    }\r\n    \r\n    console.log(`\u2705 Data validation passed (${inputData.length} records)`);\r\n    return true;\r\n  }\r\n  \r\n  // Abstract methods - must be implemented by subclasses\r\n  extractData(inputData) {\r\n    throw new Error("extractData() method must be implemented");\r\n  }\r\n  \r\n  transformData(data) {\r\n    throw new Error("transformData() method must be implemented");\r\n  }\r\n  \r\n  // Hook methods - optional to override\r\n  filterData(data) {\r\n    console.log("\ud83d\udd27 Applying default filtering (no filtering)");\r\n    return data;\r\n  }\r\n  \r\n  generateReport(result) {\r\n    console.log(`\ud83d\udcca Generated default report: Processed ${result.length} records`);\r\n  }\r\n  \r\n  // Concrete method - same for all subclasses\r\n  saveData(data) {\r\n    console.log(`\ud83d\udcbe Saving ${data.length} processed records to database`);\r\n    \r\n    // Simulate saving\r\n    const savedData = data.map((record, index) => ({\r\n      ...record,\r\n      id: index + 1,\r\n      savedAt: new Date().toISOString()\r\n    }));\r\n    \r\n    console.log("\u2705 Data saved successfully");\r\n    return savedData;\r\n  }\r\n}\r\n\r\n// Concrete implementation - CSV Data Processor\r\nclass CSVDataProcessor extends DataProcessor {\r\n  extractData(inputData) {\r\n    console.log("\ud83d\udcc4 Extracting data from CSV format...");\r\n    \r\n    // Simulate CSV parsing\r\n    const extractedData = inputData.map(row => {\r\n      const [name, age, email, city] = row.split(\',\');\r\n      return { name: name?.trim(), age: age?.trim(), email: email?.trim(), city: city?.trim() };\r\n    });\r\n    \r\n    console.log(`\u2705 Extracted ${extractedData.length} records from CSV`);\r\n    return extractedData;\r\n  }\r\n  \r\n  transformData(data) {\r\n    console.log("\ud83d\udd04 Transforming CSV data...");\r\n    \r\n    // Transform CSV data - normalize names, validate emails, etc.\r\n    const transformedData = data.map(record => ({\r\n      name: this.capitalizeName(record.name),\r\n      age: parseInt(record.age) || 0,\r\n      email: record.email?.toLowerCase(),\r\n      city: this.capitalizeCity(record.city),\r\n      type: \'csv_import\'\r\n    })).filter(record => record.name && record.email);\r\n    \r\n    console.log(`\u2705 Transformed ${transformedData.length} records`);\r\n    return transformedData;\r\n  }\r\n  \r\n  filterData(data) {\r\n    console.log("\ud83d\udd27 Applying CSV-specific filtering (age > 0, valid email)");\r\n    \r\n    const filteredData = data.filter(record => \r\n      record.age > 0 && record.email && record.email.includes(\'@\')\r\n    );\r\n    \r\n    console.log(`\u2705 Filtered to ${filteredData.length} valid records`);\r\n    return filteredData;\r\n  }\r\n  \r\n  generateReport(result) {\r\n    console.log("\ud83d\udcca Generating CSV processing report:");\r\n    \r\n    const avgAge = result.reduce((sum, r) => sum + r.age, 0) / result.length;\r\n    const cities = [...new Set(result.map(r => r.city))];\r\n    \r\n    console.log(`   \u2022 Total records processed: ${result.length}`);\r\n    console.log(`   \u2022 Average age: ${avgAge.toFixed(1)} years`);\r\n    console.log(`   \u2022 Unique cities: ${cities.length} (${cities.slice(0, 3).join(\', \')}${cities.length > 3 ? \'...\' : \'\'})`);\r\n  }\r\n  \r\n  capitalizeName(name) {\r\n    return name ? name.split(\' \').map(word => \r\n      word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()\r\n    ).join(\' \') : \'\';\r\n  }\r\n  \r\n  capitalizeCity(city) {\r\n    return city ? city.charAt(0).toUpperCase() + city.slice(1).toLowerCase() : \'\';\r\n  }\r\n}\r\n\r\n// Concrete implementation - JSON Data Processor\r\nclass JSONDataProcessor extends DataProcessor {\r\n  extractData(inputData) {\r\n    console.log("\ud83d\udcc4 Extracting data from JSON format...");\r\n    \r\n    // Simulate JSON parsing\r\n    const extractedData = inputData.map(jsonStr => {\r\n      try {\r\n        return JSON.parse(jsonStr);\r\n      } catch (e) {\r\n        console.log(`\u26a0\ufe0f Invalid JSON: ${jsonStr}`);\r\n        return null;\r\n      }\r\n    }).filter(record => record !== null);\r\n    \r\n    console.log(`\u2705 Extracted ${extractedData.length} records from JSON`);\r\n    return extractedData;\r\n  }\r\n  \r\n  transformData(data) {\r\n    console.log("\ud83d\udd04 Transforming JSON data...");\r\n    \r\n    // Transform JSON data - standardize field names, add metadata\r\n    const transformedData = data.map(record => ({\r\n      name: record.fullName || record.name || \'Unknown\',\r\n      age: record.age || record.years || 0,\r\n      email: record.emailAddress || record.email || \'\',\r\n      city: record.location || record.city || \'Unknown\',\r\n      type: \'json_import\',\r\n      originalFields: Object.keys(record).length\r\n    }));\r\n    \r\n    console.log(`\u2705 Transformed ${transformedData.length} records`);\r\n    return transformedData;\r\n  }\r\n  \r\n  filterData(data) {\r\n    console.log("\ud83d\udd27 Applying JSON-specific filtering (has name and email)");\r\n    \r\n    const filteredData = data.filter(record => \r\n      record.name !== \'Unknown\' && record.email !== \'\' && record.originalFields >= 3\r\n    );\r\n    \r\n    console.log(`\u2705 Filtered to ${filteredData.length} complete records`);\r\n    return filteredData;\r\n  }\r\n  \r\n  generateReport(result) {\r\n    console.log("\ud83d\udcca Generating JSON processing report:");\r\n    \r\n    const fieldCounts = result.map(r => r.originalFields);\r\n    const avgFields = fieldCounts.reduce((sum, count) => sum + count, 0) / fieldCounts.length;\r\n    const emailDomains = [...new Set(result.map(r => r.email.split(\'@\')[1]))];\r\n    \r\n    console.log(`   \u2022 Total records processed: ${result.length}`);\r\n    console.log(`   \u2022 Average original fields: ${avgFields.toFixed(1)}`);\r\n    console.log(`   \u2022 Email domains: ${emailDomains.length} (${emailDomains.slice(0, 3).join(\', \')}${emailDomains.length > 3 ? \'...\' : \'\'})`);\r\n  }\r\n}\r\n\r\n// Concrete implementation - XML Data Processor\r\nclass XMLDataProcessor extends DataProcessor {\r\n  extractData(inputData) {\r\n    console.log("\ud83d\udcc4 Extracting data from XML format...");\r\n    \r\n    // Simulate simple XML parsing\r\n    const extractedData = inputData.map(xmlStr => {\r\n      const nameMatch = xmlStr.match(/<name>(.*?)<\\\\/name>/);\r\n      const ageMatch = xmlStr.match(/<age>(.*?)<\\\\/age>/);\r\n      const emailMatch = xmlStr.match(/<email>(.*?)<\\\\/email>/);\r\n      const cityMatch = xmlStr.match(/<city>(.*?)<\\\\/city>/);\r\n      \r\n      return {\r\n        name: nameMatch ? nameMatch[1] : \'\',\r\n        age: ageMatch ? ageMatch[1] : \'0\',\r\n        email: emailMatch ? emailMatch[1] : \'\',\r\n        city: cityMatch ? cityMatch[1] : \'\'\r\n      };\r\n    });\r\n    \r\n    console.log(`\u2705 Extracted ${extractedData.length} records from XML`);\r\n    return extractedData;\r\n  }\r\n  \r\n  transformData(data) {\r\n    console.log("\ud83d\udd04 Transforming XML data...");\r\n    \r\n    const transformedData = data.map(record => ({\r\n      name: record.name.trim(),\r\n      age: parseInt(record.age) || 0,\r\n      email: record.email.trim().toLowerCase(),\r\n      city: record.city.trim(),\r\n      type: \'xml_import\'\r\n    }));\r\n    \r\n    console.log(`\u2705 Transformed ${transformedData.length} records`);\r\n    return transformedData;\r\n  }\r\n  \r\n  // Using default filterData (no override)\r\n  \r\n  generateReport(result) {\r\n    console.log("\ud83d\udcca Generating XML processing report:");\r\n    console.log(`   \u2022 Total records processed: ${result.length}`);\r\n    console.log(`   \u2022 Source format: XML`);\r\n  }\r\n}\r\n\r\n// Usage\r\nconsole.log("=== Data Processing Template Method Demo ===\\n");\r\n\r\nconsole.log("Sample data preparation:");\r\nconsole.log("-".repeat(25));\r\n\r\n// Sample data for different formats\r\nconst csvData = [\r\n  "john doe,25,john.doe@email.com,new york",\r\n  "jane smith,30,jane.smith@email.com,los angeles", \r\n  "bob johnson,22,bob@email.com,chicago",\r\n  "invalid row",\r\n  "alice brown,28,alice.brown@email.com,seattle"\r\n];\r\n\r\nconst jsonData = [\r\n  \'{"fullName": "Mike Wilson", "age": 35, "emailAddress": "mike@email.com", "location": "Boston"}\',\r\n  \'{"name": "Sara Davis", "years": 29, "email": "sara@email.com", "city": "Miami"}\',\r\n  \'invalid json\',\r\n  \'{"fullName": "Tom Anderson", "age": 31, "emailAddress": "tom@email.com", "location": "Denver", "phone": "555-1234"}\'\r\n];\r\n\r\nconst xmlData = [\r\n  "<record><name>Chris Lee</name><age>33</age><email>chris@email.com</email><city>Portland</city></record>",\r\n  "<record><name>Lisa Wang</name><age>27</age><email>lisa@email.com</email><city>Austin</city></record>",\r\n  "<record><name>David Kim</name><age>29</age><email>david@email.com</email><city>Phoenix</city></record>"\r\n];\r\n\r\nconsole.log(`\u2705 Prepared test data - CSV: ${csvData.length}, JSON: ${jsonData.length}, XML: ${xmlData.length}\\n`);\r\n\r\nconsole.log("=".repeat(60) + "\\n");\r\n\r\nconsole.log("1. Processing CSV Data:");\r\nconsole.log("-".repeat(23));\r\n\r\nconst csvProcessor = new CSVDataProcessor();\r\nconst csvResults = csvProcessor.processData(csvData);\r\n\r\nconsole.log("=".repeat(60) + "\\n");\r\n\r\nconsole.log("2. Processing JSON Data:");\r\nconsole.log("-".repeat(24));\r\n\r\nconst jsonProcessor = new JSONDataProcessor();\r\nconst jsonResults = jsonProcessor.processData(jsonData);\r\n\r\nconsole.log("=".repeat(60) + "\\n");\r\n\r\nconsole.log("3. Processing XML Data:");\r\nconsole.log("-".repeat(23));\r\n\r\nconst xmlProcessor = new XMLDataProcessor();\r\nconst xmlResults = xmlProcessor.processData(xmlData);\r\n\r\nconsole.log("=".repeat(60) + "\\n");\r\n\r\nconsole.log("Final Results Summary:");\r\nconsole.log("-".repeat(22));\r\n\r\nconsole.log(`\ud83d\udcca Processing Summary:`);\r\nconsole.log(`   \u2022 CSV Processor: ${csvResults ? csvResults.length : 0} records processed`);\r\nconsole.log(`   \u2022 JSON Processor: ${jsonResults ? jsonResults.length : 0} records processed`);\r\nconsole.log(`   \u2022 XML Processor: ${xmlResults ? xmlResults.length : 0} records processed`);\r\n\r\nconst totalRecords = (csvResults?.length || 0) + (jsonResults?.length || 0) + (xmlResults?.length || 0);\r\nconsole.log(`   \u2022 Total: ${totalRecords} records processed across all formats`);\n'})}),"\n",(0,a.jsx)(r.h2,{id:"-real-world-example",children:"\ud83c\udf1f Real-World Example"}),"\n",(0,a.jsx)(r.h3,{id:"game-level-generator",children:"Game Level Generator"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:"// Abstract Level Generator Template\r\nclass LevelGenerator {\r\n  constructor() {\r\n    if (this.constructor === LevelGenerator) {\r\n      throw new Error(\"LevelGenerator is abstract\");\r\n    }\r\n  }\r\n  \r\n  // Template method\r\n  generateLevel(seed, difficulty) {\r\n    console.log(`\ud83c\udfae Generating ${this.constructor.name.replace('Generator', '')} level...\\n`);\r\n    \r\n    // Step 1: Initialize random generator\r\n    this.initializeRandom(seed);\r\n    \r\n    // Step 2: Set difficulty parameters\r\n    const params = this.setupDifficultyParameters(difficulty);\r\n    \r\n    // Step 3: Generate terrain (abstract)\r\n    const terrain = this.generateTerrain(params);\r\n    \r\n    // Step 4: Place obstacles (abstract)\r\n    const obstacles = this.placeObstacles(terrain, params);\r\n    \r\n    // Step 5: Add enemies (abstract)\r\n    const enemies = this.addEnemies(terrain, params);\r\n    \r\n    // Step 6: Place collectibles (hook method)\r\n    const collectibles = this.placeCollectibles(terrain, params);\r\n    \r\n    // Step 7: Add special features (hook method)\r\n    const specialFeatures = this.addSpecialFeatures(terrain, params);\r\n    \r\n    // Step 8: Validate level (concrete method)\r\n    const level = this.validateAndFinalize(terrain, obstacles, enemies, collectibles, specialFeatures, params);\r\n    \r\n    console.log(\"\u2705 Level generation completed\\n\");\r\n    return level;\r\n  }\r\n  \r\n  // Concrete method\r\n  initializeRandom(seed) {\r\n    this.seed = seed;\r\n    this.random = this.createSeededRandom(seed);\r\n    console.log(`\ud83c\udfb2 Random generator initialized with seed: ${seed}`);\r\n  }\r\n  \r\n  createSeededRandom(seed) {\r\n    // Simple seeded random number generator\r\n    let m = 0x80000000; // 2**31\r\n    let a = 1103515245;\r\n    let c = 12345;\r\n    let state = seed;\r\n    \r\n    return () => {\r\n      state = (a * state + c) % m;\r\n      return state / (m - 1);\r\n    };\r\n  }\r\n  \r\n  // Concrete method\r\n  setupDifficultyParameters(difficulty) {\r\n    console.log(`\u2699\ufe0f Setting up parameters for ${difficulty} difficulty`);\r\n    \r\n    const baseParams = {\r\n      easy: { enemyCount: 5, obstaclePercent: 0.1, collectibleCount: 15 },\r\n      medium: { enemyCount: 10, obstaclePercent: 0.2, collectibleCount: 10 },\r\n      hard: { enemyCount: 20, obstaclePercent: 0.3, collectibleCount: 5 }\r\n    };\r\n    \r\n    const params = baseParams[difficulty] || baseParams.medium;\r\n    params.difficulty = difficulty;\r\n    params.width = 100;\r\n    params.height = 100;\r\n    \r\n    console.log(`   Enemy count: ${params.enemyCount}`);\r\n    console.log(`   Obstacle coverage: ${(params.obstaclePercent * 100)}%`);\r\n    console.log(`   Collectibles: ${params.collectibleCount}`);\r\n    \r\n    return params;\r\n  }\r\n  \r\n  // Abstract methods - must be implemented\r\n  generateTerrain(params) {\r\n    throw new Error(\"generateTerrain() must be implemented\");\r\n  }\r\n  \r\n  placeObstacles(terrain, params) {\r\n    throw new Error(\"placeObstacles() must be implemented\");\r\n  }\r\n  \r\n  addEnemies(terrain, params) {\r\n    throw new Error(\"addEnemies() must be implemented\");\r\n  }\r\n  \r\n  // Hook methods - optional to override\r\n  placeCollectibles(terrain, params) {\r\n    console.log(\"\ud83d\udc8e Placing default collectibles\");\r\n    \r\n    const collectibles = [];\r\n    for (let i = 0; i < params.collectibleCount; i++) {\r\n      collectibles.push({\r\n        type: 'coin',\r\n        x: Math.floor(this.random() * params.width),\r\n        y: Math.floor(this.random() * params.height),\r\n        value: 10\r\n      });\r\n    }\r\n    \r\n    console.log(`   Placed ${collectibles.length} coins`);\r\n    return collectibles;\r\n  }\r\n  \r\n  addSpecialFeatures(terrain, params) {\r\n    console.log(\"\u2728 No special features added (default)\");\r\n    return [];\r\n  }\r\n  \r\n  // Concrete method\r\n  validateAndFinalize(terrain, obstacles, enemies, collectibles, specialFeatures, params) {\r\n    console.log(\"\ud83d\udd0d Validating level...\");\r\n    \r\n    const level = {\r\n      seed: this.seed,\r\n      difficulty: params.difficulty,\r\n      type: this.constructor.name.replace('Generator', '').toLowerCase(),\r\n      dimensions: { width: params.width, height: params.height },\r\n      terrain,\r\n      obstacles,\r\n      enemies,\r\n      collectibles,\r\n      specialFeatures,\r\n      metadata: {\r\n        generated: new Date(),\r\n        enemyCount: enemies.length,\r\n        obstacleCount: obstacles.length,\r\n        collectibleCount: collectibles.length,\r\n        specialFeatureCount: specialFeatures.length\r\n      }\r\n    };\r\n    \r\n    // Validate level has start and end points\r\n    level.startPoint = { x: 0, y: 0 };\r\n    level.endPoint = { x: params.width - 1, y: params.height - 1 };\r\n    \r\n    console.log(\"\u2705 Level validation passed\");\r\n    console.log(`   Dimensions: ${level.dimensions.width}x${level.dimensions.height}`);\r\n    console.log(`   Elements: ${level.metadata.enemyCount} enemies, ${level.metadata.obstacleCount} obstacles, ${level.metadata.collectibleCount} collectibles`);\r\n    \r\n    return level;\r\n  }\r\n}\r\n\r\n// Concrete implementation - Forest Level\r\nclass ForestLevelGenerator extends LevelGenerator {\r\n  generateTerrain(params) {\r\n    console.log(\"\ud83c\udf32 Generating forest terrain\");\r\n    \r\n    const terrain = [];\r\n    for (let y = 0; y < params.height; y++) {\r\n      terrain[y] = [];\r\n      for (let x = 0; x < params.width; x++) {\r\n        const tileType = this.random() < 0.7 ? 'grass' : \r\n                        this.random() < 0.8 ? 'dirt' : 'water';\r\n        terrain[y][x] = {\r\n          type: tileType,\r\n          walkable: tileType !== 'water',\r\n          x, y\r\n        };\r\n      }\r\n    }\r\n    \r\n    console.log(\"   Generated forest terrain with grass, dirt, and water tiles\");\r\n    return terrain;\r\n  }\r\n  \r\n  placeObstacles(terrain, params) {\r\n    console.log(\"\ud83c\udf33 Placing forest obstacles (trees, rocks)\");\r\n    \r\n    const obstacles = [];\r\n    const targetCount = Math.floor(params.width * params.height * params.obstaclePercent);\r\n    \r\n    for (let i = 0; i < targetCount; i++) {\r\n      const x = Math.floor(this.random() * params.width);\r\n      const y = Math.floor(this.random() * params.height);\r\n      \r\n      if (terrain[y][x].walkable) {\r\n        const obstacleType = this.random() < 0.7 ? 'tree' : 'rock';\r\n        obstacles.push({\r\n          type: obstacleType,\r\n          x, y,\r\n          blocking: true,\r\n          health: obstacleType === 'tree' ? 3 : 5\r\n        });\r\n        terrain[y][x].walkable = false;\r\n      }\r\n    }\r\n    \r\n    console.log(`   Placed ${obstacles.length} forest obstacles`);\r\n    return obstacles;\r\n  }\r\n  \r\n  addEnemies(terrain, params) {\r\n    console.log(\"\ud83d\udc3b Adding forest enemies (bears, wolves)\");\r\n    \r\n    const enemies = [];\r\n    const enemyTypes = ['bear', 'wolf', 'spider'];\r\n    \r\n    for (let i = 0; i < params.enemyCount; i++) {\r\n      let placed = false;\r\n      let attempts = 0;\r\n      \r\n      while (!placed && attempts < 50) {\r\n        const x = Math.floor(this.random() * params.width);\r\n        const y = Math.floor(this.random() * params.height);\r\n        \r\n        if (terrain[y][x].walkable) {\r\n          const enemyType = enemyTypes[Math.floor(this.random() * enemyTypes.length)];\r\n          enemies.push({\r\n            type: enemyType,\r\n            x, y,\r\n            health: enemyType === 'bear' ? 30 : enemyType === 'wolf' ? 20 : 10,\r\n            damage: enemyType === 'bear' ? 8 : enemyType === 'wolf' ? 5 : 3,\r\n            speed: enemyType === 'spider' ? 3 : enemyType === 'wolf' ? 2 : 1\r\n          });\r\n          placed = true;\r\n        }\r\n        attempts++;\r\n      }\r\n    }\r\n    \r\n    console.log(`   Added ${enemies.length} forest creatures`);\r\n    return enemies;\r\n  }\r\n  \r\n  placeCollectibles(terrain, params) {\r\n    console.log(\"\ud83c\udf44 Placing forest collectibles (mushrooms, berries)\");\r\n    \r\n    const collectibles = [];\r\n    const collectibleTypes = [\r\n      { type: 'mushroom', value: 15, rarity: 0.3 },\r\n      { type: 'berries', value: 8, rarity: 0.5 },\r\n      { type: 'healing_herb', value: 25, rarity: 0.2 }\r\n    ];\r\n    \r\n    for (let i = 0; i < params.collectibleCount; i++) {\r\n      const x = Math.floor(this.random() * params.width);\r\n      const y = Math.floor(this.random() * params.height);\r\n      \r\n      if (terrain[y][x].walkable) {\r\n        const roll = this.random();\r\n        let selectedType = collectibleTypes[0];\r\n        \r\n        for (const type of collectibleTypes) {\r\n          if (roll <= type.rarity) {\r\n            selectedType = type;\r\n            break;\r\n          }\r\n        }\r\n        \r\n        collectibles.push({\r\n          type: selectedType.type,\r\n          x, y,\r\n          value: selectedType.value\r\n        });\r\n      }\r\n    }\r\n    \r\n    console.log(`   Placed ${collectibles.length} forest collectibles`);\r\n    return collectibles;\r\n  }\r\n  \r\n  addSpecialFeatures(terrain, params) {\r\n    console.log(\"\ud83c\udfdb\ufe0f Adding forest special features (ancient shrine)\");\r\n    \r\n    const features = [];\r\n    \r\n    // Add an ancient shrine for hard difficulty\r\n    if (params.difficulty === 'hard') {\r\n      const shrineX = Math.floor(params.width / 2);\r\n      const shrineY = Math.floor(params.height / 2);\r\n      \r\n      features.push({\r\n        type: 'ancient_shrine',\r\n        x: shrineX,\r\n        y: shrineY,\r\n        effect: 'heal_all',\r\n        description: 'An ancient shrine that fully heals the player'\r\n      });\r\n      \r\n      console.log(\"   Added ancient healing shrine\");\r\n    }\r\n    \r\n    // Add hidden treasure for medium/hard\r\n    if (params.difficulty !== 'easy') {\r\n      const treasureX = Math.floor(this.random() * params.width);\r\n      const treasureY = Math.floor(this.random() * params.height);\r\n      \r\n      features.push({\r\n        type: 'hidden_treasure',\r\n        x: treasureX,\r\n        y: treasureY,\r\n        effect: 'gold_bonus',\r\n        value: params.difficulty === 'hard' ? 1000 : 500,\r\n        description: 'A hidden treasure chest'\r\n      });\r\n      \r\n      console.log(\"   Added hidden treasure chest\");\r\n    }\r\n    \r\n    return features;\r\n  }\r\n}\r\n\r\n// Concrete implementation - Dungeon Level\r\nclass DungeonLevelGenerator extends LevelGenerator {\r\n  generateTerrain(params) {\r\n    console.log(\"\ud83c\udff0 Generating dungeon terrain\");\r\n    \r\n    const terrain = [];\r\n    for (let y = 0; y < params.height; y++) {\r\n      terrain[y] = [];\r\n      for (let x = 0; x < params.width; x++) {\r\n        const tileType = this.random() < 0.6 ? 'floor' : 'wall';\r\n        terrain[y][x] = {\r\n          type: tileType,\r\n          walkable: tileType === 'floor',\r\n          x, y\r\n        };\r\n      }\r\n    }\r\n    \r\n    // Create corridors\r\n    this.createCorridors(terrain, params);\r\n    \r\n    console.log(\"   Generated dungeon with rooms and corridors\");\r\n    return terrain;\r\n  }\r\n  \r\n  createCorridors(terrain, params) {\r\n    // Simple corridor creation - horizontal and vertical paths\r\n    const midY = Math.floor(params.height / 2);\r\n    const midX = Math.floor(params.width / 2);\r\n    \r\n    // Horizontal corridor\r\n    for (let x = 0; x < params.width; x++) {\r\n      terrain[midY][x] = { type: 'floor', walkable: true, x, y: midY };\r\n    }\r\n    \r\n    // Vertical corridor\r\n    for (let y = 0; y < params.height; y++) {\r\n      terrain[y][midX] = { type: 'floor', walkable: true, x: midX, y };\r\n    }\r\n  }\r\n  \r\n  placeObstacles(terrain, params) {\r\n    console.log(\"\u26e9\ufe0f Placing dungeon obstacles (pillars, traps)\");\r\n    \r\n    const obstacles = [];\r\n    const targetCount = Math.floor(params.width * params.height * params.obstaclePercent);\r\n    \r\n    for (let i = 0; i < targetCount; i++) {\r\n      const x = Math.floor(this.random() * params.width);\r\n      const y = Math.floor(this.random() * params.height);\r\n      \r\n      if (terrain[y][x].walkable) {\r\n        const obstacleType = this.random() < 0.5 ? 'pillar' : 'spike_trap';\r\n        obstacles.push({\r\n          type: obstacleType,\r\n          x, y,\r\n          blocking: obstacleType === 'pillar',\r\n          damage: obstacleType === 'spike_trap' ? 10 : 0\r\n        });\r\n        \r\n        if (obstacleType === 'pillar') {\r\n          terrain[y][x].walkable = false;\r\n        }\r\n      }\r\n    }\r\n    \r\n    console.log(`   Placed ${obstacles.length} dungeon obstacles`);\r\n    return obstacles;\r\n  }\r\n  \r\n  addEnemies(terrain, params) {\r\n    console.log(\"\ud83d\udc80 Adding dungeon enemies (skeletons, goblins)\");\r\n    \r\n    const enemies = [];\r\n    const enemyTypes = ['skeleton', 'goblin', 'orc'];\r\n    \r\n    for (let i = 0; i < params.enemyCount; i++) {\r\n      let placed = false;\r\n      let attempts = 0;\r\n      \r\n      while (!placed && attempts < 50) {\r\n        const x = Math.floor(this.random() * params.width);\r\n        const y = Math.floor(this.random() * params.height);\r\n        \r\n        if (terrain[y][x].walkable) {\r\n          const enemyType = enemyTypes[Math.floor(this.random() * enemyTypes.length)];\r\n          enemies.push({\r\n            type: enemyType,\r\n            x, y,\r\n            health: enemyType === 'orc' ? 40 : enemyType === 'goblin' ? 15 : 25,\r\n            damage: enemyType === 'orc' ? 12 : enemyType === 'goblin' ? 4 : 8,\r\n            armor: enemyType === 'skeleton' ? 3 : enemyType === 'orc' ? 2 : 0\r\n          });\r\n          placed = true;\r\n        }\r\n        attempts++;\r\n      }\r\n    }\r\n    \r\n    console.log(`   Added ${enemies.length} dungeon monsters`);\r\n    return enemies;\r\n  }\r\n  \r\n  placeCollectibles(terrain, params) {\r\n    console.log(\"\ud83d\udcb0 Placing dungeon collectibles (gold, gems)\");\r\n    \r\n    const collectibles = [];\r\n    const collectibleTypes = [\r\n      { type: 'gold_pile', value: 50, rarity: 0.4 },\r\n      { type: 'ruby', value: 100, rarity: 0.2 },\r\n      { type: 'magic_scroll', value: 75, rarity: 0.3 },\r\n      { type: 'health_potion', value: 40, rarity: 0.1 }\r\n    ];\r\n    \r\n    for (let i = 0; i < params.collectibleCount; i++) {\r\n      const x = Math.floor(this.random() * params.width);\r\n      const y = Math.floor(this.random() * params.height);\r\n      \r\n      if (terrain[y][x].walkable) {\r\n        const roll = this.random();\r\n        let selectedType = collectibleTypes[0];\r\n        \r\n        for (const type of collectibleTypes) {\r\n          if (roll <= type.rarity) {\r\n            selectedType = type;\r\n            break;\r\n          }\r\n        }\r\n        \r\n        collectibles.push({\r\n          type: selectedType.type,\r\n          x, y,\r\n          value: selectedType.value\r\n        });\r\n      }\r\n    }\r\n    \r\n    console.log(`   Placed ${collectibles.length} dungeon treasures`);\r\n    return collectibles;\r\n  }\r\n  \r\n  addSpecialFeatures(terrain, params) {\r\n    console.log(\"\ud83d\udddd\ufe0f Adding dungeon special features\");\r\n    \r\n    const features = [];\r\n    \r\n    // Always add a boss room in dungeons\r\n    const bossX = Math.floor(this.random() * params.width);\r\n    const bossY = Math.floor(this.random() * params.height);\r\n    \r\n    features.push({\r\n      type: 'boss_room',\r\n      x: bossX,\r\n      y: bossY,\r\n      effect: 'spawn_boss',\r\n      description: 'A dark chamber where the dungeon boss awaits'\r\n    });\r\n    \r\n    // Add teleportation circles for medium/hard\r\n    if (params.difficulty !== 'easy') {\r\n      const teleCount = params.difficulty === 'hard' ? 3 : 2;\r\n      \r\n      for (let i = 0; i < teleCount; i++) {\r\n        features.push({\r\n          type: 'teleporter',\r\n          x: Math.floor(this.random() * params.width),\r\n          y: Math.floor(this.random() * params.height),\r\n          effect: 'teleport',\r\n          targetId: i,\r\n          description: `Magical teleportation circle #${i + 1}`\r\n        });\r\n      }\r\n      \r\n      console.log(`   Added boss room and ${teleCount} teleporters`);\r\n    } else {\r\n      console.log(\"   Added boss room\");\r\n    }\r\n    \r\n    return features;\r\n  }\r\n}\r\n\r\n// Usage\r\nconsole.log(\"\\n=== Game Level Generator Template Method Demo ===\\n\");\r\n\r\nconsole.log(\"Generating different level types:\");\r\nconsole.log(\"-\".repeat(35));\r\n\r\nconst seed = 12345;\r\nconst difficulties = ['easy', 'medium', 'hard'];\r\n\r\nconsole.log(\"1. Forest Levels:\");\r\nconsole.log(\"-\".repeat(16));\r\n\r\nconst forestGenerator = new ForestLevelGenerator();\r\n\r\ndifficulties.forEach((difficulty, index) => {\r\n  console.log(`\\n${index + 1}.${index + 1} Forest Level - ${difficulty.toUpperCase()}:`);\r\n  console.log(\"-\".repeat(30));\r\n  \r\n  const forestLevel = forestGenerator.generateLevel(seed + index, difficulty);\r\n  \r\n  console.log(`\ud83d\udccb Generated Level Summary:`);\r\n  console.log(`   Type: ${forestLevel.type}`);\r\n  console.log(`   Seed: ${forestLevel.seed}`);\r\n  console.log(`   Size: ${forestLevel.dimensions.width}x${forestLevel.dimensions.height}`);\r\n  console.log(`   Enemies: ${forestLevel.metadata.enemyCount}`);\r\n  console.log(`   Obstacles: ${forestLevel.metadata.obstacleCount}`);\r\n  console.log(`   Collectibles: ${forestLevel.metadata.collectibleCount}`);\r\n  console.log(`   Special Features: ${forestLevel.metadata.specialFeatureCount}`);\r\n});\r\n\r\nconsole.log(\"\\n\" + \"=\".repeat(70) + \"\\n\");\r\n\r\nconsole.log(\"2. Dungeon Levels:\");\r\nconsole.log(\"-\".repeat(17));\r\n\r\nconst dungeonGenerator = new DungeonLevelGenerator();\r\n\r\ndifficulties.forEach((difficulty, index) => {\r\n  console.log(`\\n${index + 1}.${index + 1} Dungeon Level - ${difficulty.toUpperCase()}:`);\r\n  console.log(\"-\".repeat(32));\r\n  \r\n  const dungeonLevel = dungeonGenerator.generateLevel(seed + index + 100, difficulty);\r\n  \r\n  console.log(`\ud83d\udccb Generated Level Summary:`);\r\n  console.log(`   Type: ${dungeonLevel.type}`);\r\n  console.log(`   Seed: ${dungeonLevel.seed}`);  \r\n  console.log(`   Size: ${dungeonLevel.dimensions.width}x${dungeonLevel.dimensions.height}`);\r\n  console.log(`   Enemies: ${dungeonLevel.metadata.enemyCount}`);\r\n  console.log(`   Obstacles: ${dungeonLevel.metadata.obstacleCount}`);\r\n  console.log(`   Collectibles: ${dungeonLevel.metadata.collectibleCount}`);\r\n  console.log(`   Special Features: ${dungeonLevel.metadata.specialFeatureCount}`);\r\n});\r\n\r\nconsole.log(\"\\n\" + \"=\".repeat(70) + \"\\n\");\r\n\r\nconsole.log(\"Level Generation Performance Summary:\");\r\nconsole.log(\"-\".repeat(38));\r\n\r\nconst startTime = Date.now();\r\n\r\n// Generate batch of levels\r\nconst batchResults = [];\r\nfor (let i = 0; i < 6; i++) {\r\n  const generator = i % 2 === 0 ? new ForestLevelGenerator() : new DungeonLevelGenerator();\r\n  const difficulty = difficulties[i % 3];\r\n  const level = generator.generateLevel(seed + i + 1000, difficulty);\r\n  \r\n  batchResults.push({\r\n    type: level.type,\r\n    difficulty: level.difficulty,\r\n    elements: level.metadata.enemyCount + level.metadata.obstacleCount + level.metadata.collectibleCount\r\n  });\r\n}\r\n\r\nconst endTime = Date.now();\r\nconst totalTime = endTime - startTime;\r\n\r\nconsole.log(`\u23f1\ufe0f Batch Generation Results:`);\r\nconsole.log(`   Total Levels Generated: ${batchResults.length}`);\r\nconsole.log(`   Total Time: ${totalTime}ms`);\r\nconsole.log(`   Average Time per Level: ${(totalTime / batchResults.length).toFixed(1)}ms`);\r\n\r\nbatchResults.forEach((result, index) => {\r\n  console.log(`   Level ${index + 1}: ${result.type} (${result.difficulty}) - ${result.elements} elements`);\r\n});\n"})}),"\n",(0,a.jsx)(r.h2,{id:"-pros",children:"\u2705 Pros"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Code Reuse"}),": Common algorithm structure is reused across subclasses"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Consistency"}),": Ensures all implementations follow the same algorithm steps"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Extensibility"}),": Easy to add new variations by subclassing"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Control"}),": Superclass controls the algorithm flow"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Flexibility"}),": Subclasses can customize specific steps"]}),"\n"]}),"\n",(0,a.jsx)(r.h2,{id:"-cons",children:"\u274c Cons"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Inheritance Dependency"}),": Requires inheritance relationship"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Limited Flexibility"}),": Algorithm structure is fixed"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Complex Hierarchies"}),": Can lead to complex inheritance hierarchies"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Debugging Difficulty"}),": Algorithm flow spans multiple classes"]}),"\n"]}),"\n",(0,a.jsx)(r.h2,{id:"-when-to-use",children:"\ud83c\udfaf When to Use"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Similar Algorithms"}),": Multiple classes implement similar algorithms with slight variations"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Code Duplication"}),": Want to eliminate duplicate algorithm structure"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Step Customization"}),": Need to customize specific steps while keeping overall structure"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Framework Development"}),": Building frameworks where users extend base behavior"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Workflow Processing"}),": Multi-step processes with customizable steps"]}),"\n"]}),"\n",(0,a.jsx)(r.h2,{id:"-template-method-variations",children:"\ud83d\udd04 Template Method Variations"}),"\n",(0,a.jsxs)(r.h3,{id:"1-hook-methods",children:["1. ",(0,a.jsx)(r.strong,{children:"Hook Methods"})]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:"class TemplateWithHooks {\r\n  templateMethod() {\r\n    this.stepOne();\r\n    \r\n    if (this.shouldExecuteStepTwo()) {\r\n      this.stepTwo();\r\n    }\r\n    \r\n    this.stepThree();\r\n  }\r\n  \r\n  // Hook method - default implementation\r\n  shouldExecuteStepTwo() {\r\n    return true;\r\n  }\r\n}\n"})}),"\n",(0,a.jsxs)(r.h3,{id:"2-strategy-template-hybrid",children:["2. ",(0,a.jsx)(r.strong,{children:"Strategy-Template Hybrid"})]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:"class StrategyTemplate {\r\n  constructor(strategy) {\r\n    this.strategy = strategy;\r\n  }\r\n  \r\n  templateMethod() {\r\n    this.beforeProcess();\r\n    this.strategy.execute();\r\n    this.afterProcess();\r\n  }\r\n}\n"})}),"\n",(0,a.jsxs)(r.h3,{id:"3-functional-template-method",children:["3. ",(0,a.jsx)(r.strong,{children:"Functional Template Method"})]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:"class FunctionalTemplate {\r\n  templateMethod(stepImplementations) {\r\n    this.stepOne();\r\n    stepImplementations.customStep();\r\n    this.stepThree();\r\n  }\r\n}\n"})}),"\n",(0,a.jsx)(r.h2,{id:"-related-patterns",children:"\ud83d\udd17 Related Patterns"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Strategy"}),": Both define algorithm families, but Template Method uses inheritance while Strategy uses composition"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Factory Method"}),": Often used within Template Method to create objects"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Command"}),": Template steps can be implemented as commands"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Decorator"}),": Can be used to add behavior to template steps"]}),"\n"]}),"\n",(0,a.jsx)(r.h2,{id:"-further-reading",children:"\ud83d\udcda Further Reading"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://refactoring.guru/design-patterns/template-method",children:"Template Method Pattern - Refactoring.Guru"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://en.wikipedia.org/wiki/Design_Patterns",children:"Gang of Four Design Patterns"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://en.wikipedia.org/wiki/Hollywood_principle",children:"Hollywood Principle: Don't call us, we'll call you"})}),"\n"]})]})}function m(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,a.jsx)(r,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>s,x:()=>l});var t=n(6540);const a={},o=t.createContext(a);function s(e){const r=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(o.Provider,{value:r},e.children)}}}]);