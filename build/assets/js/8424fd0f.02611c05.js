"use strict";(globalThis.webpackChunka=globalThis.webpackChunka||[]).push([[5561],{910:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"functional-programming/monads/README","title":"\ud83c\udfd7\ufe0f Monads: Advanced Functional Patterns","description":"Master monads: the most powerful abstraction in functional programming for handling context and chaining operations","source":"@site/docs/functional-programming/monads/README.md","sourceDirName":"functional-programming/monads","slug":"/functional-programming/monads/","permalink":"/docs/functional-programming/monads/","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"\ud83c\udfad Functor Functions & Mappable Structures","permalink":"/docs/functional-programming/functor-functions/"},"next":{"title":"\ud83c\udfaf Pure Functions and Side Effects","permalink":"/docs/functional-programming/pure-function-and-side-effect/"}}');var i=t(4848),r=t(8453);const s={},o="\ud83c\udfd7\ufe0f Monads: Advanced Functional Patterns",l={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"What is a Monad?",id:"what-is-a-monad",level:2},{value:"Monad Interface",id:"monad-interface",level:3},{value:"Mathematical Foundation",id:"mathematical-foundation",level:3},{value:"The Problem Monads Solve",id:"the-problem-monads-solve",level:3},{value:"Monad Laws",id:"monad-laws",level:2},{value:"Law Verification Utility",id:"law-verification-utility",level:3},{value:"Why Monads Matter",id:"why-monads-matter",level:2},{value:"1. <strong>Composability</strong>",id:"1-composability",level:3},{value:"2. <strong>Context Preservation</strong>",id:"2-context-preservation",level:3},{value:"3. <strong>Separation of Concerns</strong>",id:"3-separation-of-concerns",level:3},{value:"4. <strong>Abstraction Power</strong>",id:"4-abstraction-power",level:3},{value:"Identity Monad",id:"identity-monad",level:2},{value:"Implementation",id:"implementation",level:3},{value:"Maybe Monad",id:"maybe-monad",level:2},{value:"Enhanced Maybe Implementation",id:"enhanced-maybe-implementation",level:3},{value:"Maybe for Safe Operations",id:"maybe-for-safe-operations",level:3},{value:"Either Monad",id:"either-monad",level:2},{value:"Enhanced Either Implementation",id:"enhanced-either-implementation",level:3},{value:"IO Monad",id:"io-monad",level:2},{value:"Enhanced IO Implementation",id:"enhanced-io-implementation",level:3},{value:"State Monad",id:"state-monad",level:2},{value:"State Monad Implementation",id:"state-monad-implementation",level:3},{value:"List Monad",id:"list-monad",level:2},{value:"List Monad Implementation",id:"list-monad-implementation",level:3},{value:"Reader Monad",id:"reader-monad",level:2},{value:"Reader Monad Implementation",id:"reader-monad-implementation",level:3},{value:"Writer Monad",id:"writer-monad",level:2},{value:"Writer Monad Implementation",id:"writer-monad-implementation",level:3},{value:"Async Monad",id:"async-monad",level:2},{value:"Async Monad Implementation",id:"async-monad-implementation",level:3},{value:"Monad Transformers",id:"monad-transformers",level:2},{value:"MaybeT (Maybe Transformer)",id:"maybet-maybe-transformer",level:3},{value:"Real-World Applications",id:"real-world-applications",level:2},{value:"Form Validation Pipeline",id:"form-validation-pipeline",level:3},{value:"Database Query Pipeline",id:"database-query-pipeline",level:3},{value:"Configuration Management",id:"configuration-management",level:3},{value:"\ud83c\udfaf Key Takeaways",id:"-key-takeaways",level:2}];function d(n){const e={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"\ufe0f-monads-advanced-functional-patterns",children:"\ud83c\udfd7\ufe0f Monads: Advanced Functional Patterns"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.em,{children:"Master monads: the most powerful abstraction in functional programming for handling context and chaining operations"})}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#what-is-a-monad",children:"What is a Monad?"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#monad-laws",children:"Monad Laws"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#why-monads-matter",children:"Why Monads Matter"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#identity-monad",children:"Identity Monad"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#maybe-monad",children:"Maybe Monad"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#either-monad",children:"Either Monad"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#io-monad",children:"IO Monad"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#state-monad",children:"State Monad"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#list-monad",children:"List Monad"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#reader-monad",children:"Reader Monad"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#writer-monad",children:"Writer Monad"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#async-monad",children:"Async Monad"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#monad-transformers",children:"Monad Transformers"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#real-world-applications",children:"Real-World Applications"})}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"what-is-a-monad",children:"What is a Monad?"}),"\n",(0,i.jsxs)(e.p,{children:["A ",(0,i.jsx)(e.strong,{children:"monad"})," is a design pattern that provides a way to wrap values and chain operations on those wrapped values. Monads are functors that also implement ",(0,i.jsx)(e.code,{children:"flatMap"})," (also called ",(0,i.jsx)(e.code,{children:"bind"})," or ",(0,i.jsx)(e.code,{children:">>="}),") and follow specific laws."]}),"\n",(0,i.jsx)(e.h3,{id:"monad-interface",children:"Monad Interface"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// Generic monad interface\nclass Monad {\n    constructor(value) {\n        this.value = value;\n    }\n    \n    // Functor interface\n    map(fn) {\n        return this.flatMap(x => Monad.of(fn(x)));\n    }\n    \n    // Monad interface (the key method)\n    flatMap(fn) {\n        // Implementation varies by monad type\n        throw new Error('flatMap must be implemented by subclass');\n    }\n    \n    // Pointed functor interface  \n    static of(value) {\n        return new Monad(value);\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"mathematical-foundation",children:"Mathematical Foundation"}),"\n",(0,i.jsx)(e.p,{children:"Monads come from category theory and must satisfy three laws:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Left Identity"}),": ",(0,i.jsx)(e.code,{children:"M.of(a).flatMap(f) === f(a)"})]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Right Identity"}),": ",(0,i.jsx)(e.code,{children:"m.flatMap(M.of) === m"})]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Associativity"}),": ",(0,i.jsx)(e.code,{children:"m.flatMap(f).flatMap(g) === m.flatMap(x => f(x).flatMap(g))"})]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"the-problem-monads-solve",children:"The Problem Monads Solve"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u274c Without monads - nested, hard to read\nconst processUser = (userId) => {\n    const user = getUser(userId);\n    if (user) {\n        const profile = getProfile(user.profileId);\n        if (profile) {\n            const preferences = getPreferences(profile.prefId);\n            if (preferences) {\n                return updatePreferences(preferences, { theme: 'dark' });\n            }\n        }\n    }\n    return null;\n};\n\n// \u2705 With monads - flat, composable\nconst processUserMonadic = (userId) =>\n    getUser(userId)\n        .flatMap(user => getProfile(user.profileId))\n        .flatMap(profile => getPreferences(profile.prefId))\n        .flatMap(prefs => updatePreferences(prefs, { theme: 'dark' }));\n"})}),"\n",(0,i.jsx)(e.h2,{id:"monad-laws",children:"Monad Laws"}),"\n",(0,i.jsx)(e.p,{children:"All monads must obey three fundamental laws:"}),"\n",(0,i.jsx)(e.h3,{id:"law-verification-utility",children:"Law Verification Utility"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Utility to verify monad laws\nconst verifyMonadLaws = (MonadType, value, f, g) => {\n    const M = MonadType;\n    const m = M.of(value);\n    \n    // Left Identity: M.of(a).flatMap(f) === f(a)\n    const leftIdentity = \n        JSON.stringify(M.of(value).flatMap(f).value) === \n        JSON.stringify(f(value).value);\n    \n    // Right Identity: m.flatMap(M.of) === m\n    const rightIdentity = \n        JSON.stringify(m.flatMap(M.of).value) === \n        JSON.stringify(m.value);\n    \n    // Associativity: m.flatMap(f).flatMap(g) === m.flatMap(x => f(x).flatMap(g))\n    const associativity = \n        JSON.stringify(m.flatMap(f).flatMap(g).value) === \n        JSON.stringify(m.flatMap(x => f(x).flatMap(g)).value);\n    \n    return {\n        leftIdentity,\n        rightIdentity,\n        associativity,\n        valid: leftIdentity && rightIdentity && associativity\n    };\n};\n"})}),"\n",(0,i.jsx)(e.h2,{id:"why-monads-matter",children:"Why Monads Matter"}),"\n",(0,i.jsx)(e.p,{children:"Monads provide:"}),"\n",(0,i.jsxs)(e.h3,{id:"1-composability",children:["1. ",(0,i.jsx)(e.strong,{children:"Composability"})]}),"\n",(0,i.jsx)(e.p,{children:"Chain operations without nested callbacks or complex error handling."}),"\n",(0,i.jsxs)(e.h3,{id:"2-context-preservation",children:["2. ",(0,i.jsx)(e.strong,{children:"Context Preservation"})]}),"\n",(0,i.jsx)(e.p,{children:"Handle null values, errors, async operations, or state while maintaining a consistent interface."}),"\n",(0,i.jsxs)(e.h3,{id:"3-separation-of-concerns",children:["3. ",(0,i.jsx)(e.strong,{children:"Separation of Concerns"})]}),"\n",(0,i.jsx)(e.p,{children:'Separate the "what" (business logic) from the "how" (context handling).'}),"\n",(0,i.jsxs)(e.h3,{id:"4-abstraction-power",children:["4. ",(0,i.jsx)(e.strong,{children:"Abstraction Power"})]}),"\n",(0,i.jsx)(e.p,{children:"Write generic code that works with any monad type."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Generic monadic pipeline\nconst pipeline = (monad, ...operations) =>\n    operations.reduce((acc, op) => acc.flatMap(op), monad);\n\n// Works with any monad\nconst maybeResult = pipeline(\n    Maybe.of(5),\n    x => Maybe.of(x * 2),\n    x => Maybe.of(x + 3),\n    x => Maybe.of(`Result: ${x}`)\n);\n\nconst eitherResult = pipeline(\n    Either.of(5),\n    x => Either.of(x * 2),\n    x => Either.of(x + 3),\n    x => Either.of(`Result: ${x}`)\n);\n"})}),"\n",(0,i.jsx)(e.h2,{id:"identity-monad",children:"Identity Monad"}),"\n",(0,i.jsx)(e.p,{children:"The simplest monad - it just wraps a value without adding any special behavior."}),"\n",(0,i.jsx)(e.h3,{id:"implementation",children:"Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Identity monad\nclass Identity {\n    constructor(value) {\n        this.value = value;\n    }\n    \n    map(fn) {\n        return Identity.of(fn(this.value));\n    }\n    \n    flatMap(fn) {\n        return fn(this.value);\n    }\n    \n    static of(value) {\n        return new Identity(value);\n    }\n    \n    inspect() {\n        return `Identity(${this.value})`;\n    }\n}\n\n// Usage - mainly for learning and testing\nconst result = Identity.of(5)\n    .flatMap(x => Identity.of(x * 2))\n    .flatMap(x => Identity.of(x + 3))\n    .map(x => `Final: ${x}`);\n\nconsole.log(result.inspect()); // Identity(Final: 13)\n\n// Verify laws\nconst addOne = x => Identity.of(x + 1);\nconst double = x => Identity.of(x * 2);\nconsole.log(verifyMonadLaws(Identity, 5, addOne, double)); // All true\n"})}),"\n",(0,i.jsx)(e.h2,{id:"maybe-monad",children:"Maybe Monad"}),"\n",(0,i.jsx)(e.p,{children:"Handles null/undefined values elegantly, preventing null pointer exceptions."}),"\n",(0,i.jsx)(e.h3,{id:"enhanced-maybe-implementation",children:"Enhanced Maybe Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Maybe monad with full interface\nclass Maybe {\n    constructor(value) {\n        this.value = value;\n    }\n    \n    isNothing() {\n        return this.value === null || this.value === undefined;\n    }\n    \n    isSomething() {\n        return !this.isNothing();\n    }\n    \n    map(fn) {\n        return this.isNothing() ? this : Maybe.of(fn(this.value));\n    }\n    \n    flatMap(fn) {\n        return this.isNothing() ? this : fn(this.value);\n    }\n    \n    filter(predicate) {\n        return this.isNothing() || predicate(this.value) \n            ? this \n            : Maybe.nothing();\n    }\n    \n    getOrElse(defaultValue) {\n        return this.isNothing() ? defaultValue : this.value;\n    }\n    \n    orElse(alternativeMaybe) {\n        return this.isNothing() ? alternativeMaybe : this;\n    }\n    \n    static of(value) {\n        return value === null || value === undefined \n            ? Maybe.nothing() \n            : new Maybe(value);\n    }\n    \n    static nothing() {\n        return new Maybe(null);\n    }\n    \n    static some(value) {\n        return new Maybe(value);\n    }\n    \n    inspect() {\n        return this.isNothing() \n            ? 'Maybe.Nothing' \n            : `Maybe.Some(${JSON.stringify(this.value)})`;\n    }\n}\n\n// Advanced Maybe usage\nconst users = [\n    { id: 1, name: 'John', email: 'john@example.com' },\n    { id: 2, name: 'Jane' },\n    null\n];\n\nconst getUserEmail = (user) =>\n    Maybe.of(user)\n        .filter(u => u.id > 0)\n        .map(u => u.email)\n        .filter(email => email && email.includes('@'))\n        .map(email => email.toLowerCase());\n\nusers.forEach((user, i) => {\n    const email = getUserEmail(user);\n    console.log(`User ${i}: ${email.getOrElse('No valid email')}`);\n});\n// User 0: john@example.com\n// User 1: No valid email\n// User 2: No valid email\n"})}),"\n",(0,i.jsx)(e.h3,{id:"maybe-for-safe-operations",children:"Maybe for Safe Operations"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Safe mathematical operations\nconst safeDivide = (a, b) => \n    b === 0 ? Maybe.nothing() : Maybe.of(a / b);\n\nconst safeSqrt = (x) => \n    x < 0 ? Maybe.nothing() : Maybe.of(Math.sqrt(x));\n\nconst safeLog = (x) => \n    x <= 0 ? Maybe.nothing() : Maybe.of(Math.log(x));\n\n// Chain safe operations\nconst calculate = (a, b) =>\n    safeDivide(a, b)\n        .flatMap(safeSqrt)\n        .flatMap(safeLog)\n        .map(result => Math.round(result * 1000) / 1000);\n\nconsole.log(calculate(100, 4).inspect()); // Maybe.Some(0.693)\nconsole.log(calculate(100, 0).inspect()); // Maybe.Nothing\nconsole.log(calculate(-100, 4).inspect()); // Maybe.Nothing\n"})}),"\n",(0,i.jsx)(e.h2,{id:"either-monad",children:"Either Monad"}),"\n",(0,i.jsx)(e.p,{children:"Represents computations that might fail, holding either a success value (Right) or an error (Left)."}),"\n",(0,i.jsx)(e.h3,{id:"enhanced-either-implementation",children:"Enhanced Either Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Either monad for error handling\nclass Either {\n    constructor(value, isRight = true) {\n        this.value = value;\n        this.isRight = isRight;\n    }\n    \n    isLeft() {\n        return !this.isRight;\n    }\n    \n    map(fn) {\n        return this.isLeft() ? this : Either.right(fn(this.value));\n    }\n    \n    mapLeft(fn) {\n        return this.isLeft() ? Either.left(fn(this.value)) : this;\n    }\n    \n    flatMap(fn) {\n        return this.isLeft() ? this : fn(this.value);\n    }\n    \n    fold(leftFn, rightFn) {\n        return this.isLeft() ? leftFn(this.value) : rightFn(this.value);\n    }\n    \n    swap() {\n        return new Either(this.value, !this.isRight);\n    }\n    \n    bimap(leftFn, rightFn) {\n        return this.isLeft() \n            ? Either.left(leftFn(this.value))\n            : Either.right(rightFn(this.value));\n    }\n    \n    static left(value) {\n        return new Either(value, false);\n    }\n    \n    static right(value) {\n        return new Either(value, true);\n    }\n    \n    static of(value) {\n        return Either.right(value);\n    }\n    \n    static try(fn) {\n        try {\n            return Either.right(fn());\n        } catch (error) {\n            return Either.left(error.message);\n        }\n    }\n    \n    static fromNullable(value, errorMessage = 'Value is null') {\n        return value === null || value === undefined\n            ? Either.left(errorMessage)\n            : Either.right(value);\n    }\n    \n    inspect() {\n        return this.isLeft() \n            ? `Either.Left(${JSON.stringify(this.value)})` \n            : `Either.Right(${JSON.stringify(this.value)})`;\n    }\n}\n\n// Validation with Either\nconst validateUser = (userData) => {\n    const validateName = (user) =>\n        !user.name ? Either.left('Name is required') :\n        user.name.length < 2 ? Either.left('Name too short') :\n        Either.right(user);\n    \n    const validateEmail = (user) =>\n        !user.email ? Either.left('Email is required') :\n        !user.email.includes('@') ? Either.left('Invalid email') :\n        Either.right(user);\n    \n    const validateAge = (user) =>\n        user.age === undefined ? Either.left('Age is required') :\n        user.age < 0 ? Either.left('Age cannot be negative') :\n        user.age > 150 ? Either.left('Age too high') :\n        Either.right(user);\n    \n    return Either.right(userData)\n        .flatMap(validateName)\n        .flatMap(validateEmail)\n        .flatMap(validateAge);\n};\n\n// Test validation\nconst user1 = { name: 'John', email: 'john@example.com', age: 25 };\nconst user2 = { name: 'J', email: 'invalid', age: -5 };\n\nconsole.log(validateUser(user1).inspect()); // Either.Right({...})\nconsole.log(validateUser(user2).inspect()); // Either.Left(\"Name too short\")\n"})}),"\n",(0,i.jsx)(e.h2,{id:"io-monad",children:"IO Monad"}),"\n",(0,i.jsx)(e.p,{children:"Wraps side-effectful operations, allowing composition while deferring execution."}),"\n",(0,i.jsx)(e.h3,{id:"enhanced-io-implementation",children:"Enhanced IO Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 IO monad for side effects\nclass IO {\n    constructor(effect) {\n        if (typeof effect !== 'function') {\n            throw new Error('IO requires a function');\n        }\n        this.effect = effect;\n    }\n    \n    map(fn) {\n        return new IO(() => fn(this.effect()));\n    }\n    \n    flatMap(fn) {\n        return new IO(() => fn(this.effect()).effect());\n    }\n    \n    run() {\n        return this.effect();\n    }\n    \n    static of(value) {\n        return new IO(() => value);\n    }\n    \n    static from(effect) {\n        return new IO(effect);\n    }\n    \n    static lift(value) {\n        return IO.of(value);\n    }\n    \n    inspect() {\n        return 'IO(?)';\n    }\n}\n\n// IO utilities\nconst log = (message) => IO.from(() => {\n    console.log(message);\n    return message;\n});\n\nconst readFile = (filename) => IO.from(() => {\n    console.log(`Reading ${filename}...`);\n    return `Contents of ${filename}`;\n});\n\nconst writeFile = (filename, content) => IO.from(() => {\n    console.log(`Writing to ${filename}...`);\n    return `Written: ${content}`;\n});\n\nconst currentTime = () => IO.from(() => new Date().toISOString());\n\n// Compose IO operations\nconst fileProcessing = readFile('input.txt')\n    .map(content => content.toUpperCase())\n    .flatMap(content => log(`Processing: ${content}`))\n    .flatMap(content => currentTime().map(time => `${content} at ${time}`))\n    .flatMap(result => writeFile('output.txt', result));\n\nconsole.log('Composed IO operation (not executed yet)');\nconst result = fileProcessing.run();\nconsole.log('Final result:', result);\n"})}),"\n",(0,i.jsx)(e.h2,{id:"state-monad",children:"State Monad"}),"\n",(0,i.jsx)(e.p,{children:"Manages stateful computations in a functional way."}),"\n",(0,i.jsx)(e.h3,{id:"state-monad-implementation",children:"State Monad Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 State monad for stateful computations\nclass State {\n    constructor(runState) {\n        this.runState = runState; // (state) => [value, newState]\n    }\n    \n    map(fn) {\n        return new State(state => {\n            const [value, newState] = this.runState(state);\n            return [fn(value), newState];\n        });\n    }\n    \n    flatMap(fn) {\n        return new State(state => {\n            const [value, newState] = this.runState(state);\n            return fn(value).runState(newState);\n        });\n    }\n    \n    run(initialState) {\n        return this.runState(initialState);\n    }\n    \n    static of(value) {\n        return new State(state => [value, state]);\n    }\n    \n    static get() {\n        return new State(state => [state, state]);\n    }\n    \n    static put(newState) {\n        return new State(state => [undefined, newState]);\n    }\n    \n    static modify(fn) {\n        return new State(state => [undefined, fn(state)]);\n    }\n    \n    inspect() {\n        return 'State(?)';\n    }\n}\n\n// Example: Counter with State monad\nconst increment = State.modify(count => count + 1);\nconst decrement = State.modify(count => count - 1);\nconst getValue = State.get();\n\n// Compose stateful operations\nconst counterProgram = increment\n    .flatMap(() => increment)\n    .flatMap(() => decrement)\n    .flatMap(() => getValue)\n    .map(value => `Final count: ${value}`);\n\nconst [result, finalState] = counterProgram.run(0);\nconsole.log(result); // \"Final count: 1\"\nconsole.log(finalState); // 1\n\n// Example: Stack operations\nconst push = (item) => State.modify(stack => [...stack, item]);\nconst pop = () => State.get()\n    .flatMap(stack => \n        stack.length === 0 \n            ? State.of(null)\n            : State.put(stack.slice(0, -1))\n                .flatMap(() => State.of(stack[stack.length - 1]))\n    );\n\nconst stackProgram = push(1)\n    .flatMap(() => push(2))\n    .flatMap(() => push(3))\n    .flatMap(() => pop())\n    .flatMap(popped => State.get()\n        .map(stack => ({ popped, remaining: stack })));\n\nconst [stackResult, finalStack] = stackProgram.run([]);\nconsole.log(stackResult); // { popped: 3, remaining: [1, 2] }\n"})}),"\n",(0,i.jsx)(e.h2,{id:"list-monad",children:"List Monad"}),"\n",(0,i.jsx)(e.p,{children:"Represents non-deterministic computations (computations with multiple possible results)."}),"\n",(0,i.jsx)(e.h3,{id:"list-monad-implementation",children:"List Monad Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 List monad for non-deterministic computations\nclass List {\n    constructor(items) {\n        this.items = Array.isArray(items) ? items : [items];\n    }\n    \n    map(fn) {\n        return new List(this.items.map(fn));\n    }\n    \n    flatMap(fn) {\n        return new List(\n            this.items.reduce((acc, item) => {\n                const result = fn(item);\n                return acc.concat(result.items);\n            }, [])\n        );\n    }\n    \n    filter(predicate) {\n        return new List(this.items.filter(predicate));\n    }\n    \n    concat(otherList) {\n        return new List([...this.items, ...otherList.items]);\n    }\n    \n    static of(value) {\n        return new List([value]);\n    }\n    \n    static empty() {\n        return new List([]);\n    }\n    \n    static from(items) {\n        return new List(items);\n    }\n    \n    inspect() {\n        return `List([${this.items.join(', ')}])`;\n    }\n}\n\n// Non-deterministic computations\nconst choices = (options) => List.from(options);\nconst diceRoll = choices([1, 2, 3, 4, 5, 6]);\nconst coinFlip = choices(['heads', 'tails']);\n\n// All possible combinations\nconst gameOutcome = diceRoll\n    .flatMap(die => \n        coinFlip.map(coin => ({ die, coin }))\n    )\n    .filter(outcome => outcome.die > 3);\n\nconsole.log(gameOutcome.inspect());\n// List([{die: 4, coin: 'heads'}, {die: 4, coin: 'tails'}, ...])\n\n// Pythagorean triples\nconst range = (start, end) => \n    List.from(Array.from({ length: end - start + 1 }, (_, i) => start + i));\n\nconst pythagoreanTriples = range(1, 20)\n    .flatMap(a => \n        range(a, 20).flatMap(b =>\n            range(b, 20).flatMap(c =>\n                a * a + b * b === c * c \n                    ? List.of([a, b, c])\n                    : List.empty()\n            )\n        )\n    );\n\nconsole.log(pythagoreanTriples.inspect());\n// List([[3, 4, 5], [5, 12, 13], [6, 8, 10], ...])\n"})}),"\n",(0,i.jsx)(e.h2,{id:"reader-monad",children:"Reader Monad"}),"\n",(0,i.jsx)(e.p,{children:"Represents computations that depend on a shared environment/context."}),"\n",(0,i.jsx)(e.h3,{id:"reader-monad-implementation",children:"Reader Monad Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Reader monad for dependency injection\nclass Reader {\n    constructor(computation) {\n        this.computation = computation; // (environment) => value\n    }\n    \n    map(fn) {\n        return new Reader(env => fn(this.computation(env)));\n    }\n    \n    flatMap(fn) {\n        return new Reader(env => fn(this.computation(env)).computation(env));\n    }\n    \n    run(environment) {\n        return this.computation(environment);\n    }\n    \n    static of(value) {\n        return new Reader(env => value);\n    }\n    \n    static ask() {\n        return new Reader(env => env);\n    }\n    \n    static asks(selector) {\n        return new Reader(env => selector(env));\n    }\n    \n    inspect() {\n        return 'Reader(?)';\n    }\n}\n\n// Example: Configuration-dependent computations\nconst getConfig = (key) => Reader.asks(env => env.config[key]);\nconst getUser = (id) => Reader.asks(env => env.database.users[id]);\nconst log = (message) => Reader.asks(env => env.logger.log(message));\n\nconst processUser = (userId) =>\n    getUser(userId)\n        .flatMap(user => \n            getConfig('greeting')\n                .map(greeting => `${greeting}, ${user.name}!`)\n        )\n        .flatMap(message => \n            log(message).map(() => message)\n        );\n\n// Environment setup\nconst environment = {\n    config: { greeting: 'Hello' },\n    database: { \n        users: { \n            1: { name: 'Alice' }, \n            2: { name: 'Bob' } \n        } \n    },\n    logger: { log: (msg) => console.log(`LOG: ${msg}`) }\n};\n\nconst result = processUser(1).run(environment);\n// LOG: Hello, Alice!\nconsole.log(result); // \"Hello, Alice!\"\n"})}),"\n",(0,i.jsx)(e.h2,{id:"writer-monad",children:"Writer Monad"}),"\n",(0,i.jsx)(e.p,{children:"Accumulates values alongside computations (useful for logging, debugging, or collecting metadata)."}),"\n",(0,i.jsx)(e.h3,{id:"writer-monad-implementation",children:"Writer Monad Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Writer monad for logging/accumulation\nclass Writer {\n    constructor(value, log) {\n        this.value = value;\n        this.log = log;\n    }\n    \n    map(fn) {\n        return new Writer(fn(this.value), this.log);\n    }\n    \n    flatMap(fn) {\n        const result = fn(this.value);\n        return new Writer(result.value, this.log.concat(result.log));\n    }\n    \n    static of(value) {\n        return new Writer(value, []);\n    }\n    \n    static tell(message) {\n        return new Writer(undefined, [message]);\n    }\n    \n    inspect() {\n        return `Writer(${JSON.stringify(this.value)}, [${this.log.join(', ')}])`;\n    }\n}\n\n// Example: Computation with logging\nconst add = (a, b) => \n    Writer.tell(`Adding ${a} + ${b}`)\n        .flatMap(() => Writer.of(a + b));\n\nconst multiply = (a, b) => \n    Writer.tell(`Multiplying ${a} * ${b}`)\n        .flatMap(() => Writer.of(a * b));\n\nconst computation = add(3, 4)\n    .flatMap(sum => multiply(sum, 2))\n    .flatMap(product => Writer.tell(`Final result: ${product}`)\n        .flatMap(() => Writer.of(product)));\n\nconsole.log(computation.inspect());\n// Writer(14, [Adding 3 + 4, Multiplying 7 * 2, Final result: 14])\n\n// Example: Factorial with step tracking\nconst factorial = (n) => {\n    if (n <= 1) {\n        return Writer.tell(`Base case: ${n}! = 1`)\n            .flatMap(() => Writer.of(1));\n    }\n    \n    return factorial(n - 1)\n        .flatMap(prev => Writer.tell(`${n}! = ${n} * ${prev}`)\n            .flatMap(() => Writer.of(n * prev)));\n};\n\nconst factResult = factorial(5);\nconsole.log(factResult.inspect());\nconsole.log('Steps:', factResult.log);\n"})}),"\n",(0,i.jsx)(e.h2,{id:"async-monad",children:"Async Monad"}),"\n",(0,i.jsx)(e.p,{children:"Handles asynchronous computations in a monadic way."}),"\n",(0,i.jsx)(e.h3,{id:"async-monad-implementation",children:"Async Monad Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Async monad (enhanced Promise)\nclass Async {\n    constructor(promise) {\n        this.promise = promise;\n    }\n    \n    map(fn) {\n        return new Async(this.promise.then(fn));\n    }\n    \n    flatMap(fn) {\n        return new Async(\n            this.promise.then(value => fn(value).promise)\n        );\n    }\n    \n    catch(errorHandler) {\n        return new Async(this.promise.catch(errorHandler));\n    }\n    \n    finally(finallyHandler) {\n        return new Async(this.promise.finally(finallyHandler));\n    }\n    \n    run() {\n        return this.promise;\n    }\n    \n    static of(value) {\n        return new Async(Promise.resolve(value));\n    }\n    \n    static reject(error) {\n        return new Async(Promise.reject(error));\n    }\n    \n    static all(asyncs) {\n        return new Async(\n            Promise.all(asyncs.map(async => async.promise))\n        );\n    }\n    \n    static race(asyncs) {\n        return new Async(\n            Promise.race(asyncs.map(async => async.promise))\n        );\n    }\n    \n    inspect() {\n        return 'Async(Promise)';\n    }\n}\n\n// Example: API calls with Async monad\nconst fetchUser = (id) => \n    Async.of(`User ${id}`); // Simulated async operation\n\nconst fetchPosts = (user) => \n    Async.of([`${user}'s post 1`, `${user}'s post 2`]);\n\nconst fetchComments = (post) => \n    Async.of([`Comment on ${post}`]);\n\nconst getUserData = (userId) =>\n    fetchUser(userId)\n        .flatMap(user => \n            fetchPosts(user)\n                .map(posts => ({ user, posts }))\n        )\n        .flatMap(userData => \n            Async.all(\n                userData.posts.map(post => \n                    fetchComments(post).map(comments => ({ post, comments }))\n                )\n            ).map(postComments => ({ ...userData, postComments }))\n        );\n\n// Usage\ngetUserData(123).run()\n    .then(result => console.log('User data:', result))\n    .catch(error => console.error('Error:', error));\n"})}),"\n",(0,i.jsx)(e.h2,{id:"monad-transformers",children:"Monad Transformers"}),"\n",(0,i.jsx)(e.p,{children:"Combine multiple monads to handle complex scenarios."}),"\n",(0,i.jsx)(e.h3,{id:"maybet-maybe-transformer",children:"MaybeT (Maybe Transformer)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 MaybeT - Maybe transformer for Promise<Maybe<T>>\nclass MaybeT {\n    constructor(promise) {\n        this.promise = promise; // Promise<Maybe<T>>\n    }\n    \n    map(fn) {\n        return new MaybeT(\n            this.promise.then(maybe => maybe.map(fn))\n        );\n    }\n    \n    flatMap(fn) {\n        return new MaybeT(\n            this.promise.then(maybe => \n                maybe.isNothing() \n                    ? Promise.resolve(Maybe.nothing())\n                    : fn(maybe.value).promise\n            )\n        );\n    }\n    \n    run() {\n        return this.promise;\n    }\n    \n    static lift(promise) {\n        return new MaybeT(promise.then(Maybe.of));\n    }\n    \n    static of(value) {\n        return new MaybeT(Promise.resolve(Maybe.of(value)));\n    }\n    \n    static nothing() {\n        return new MaybeT(Promise.resolve(Maybe.nothing()));\n    }\n}\n\n// Example: Safe async operations\nconst safeParseJSON = (str) => \n    MaybeT.of(str)\n        .map(s => {\n            try {\n                return JSON.parse(s);\n            } catch (e) {\n                return null;\n            }\n        })\n        .flatMap(obj => obj ? MaybeT.of(obj) : MaybeT.nothing());\n\nconst fetchAndParseUser = (url) =>\n    MaybeT.lift(fetch(url).then(r => r.text()))\n        .flatMap(safeParseJSON)\n        .map(user => ({ ...user, fetched: true }));\n\n// Usage would be:\n// fetchAndParseUser('/api/user/123').run()\n//     .then(maybe => maybe.fold(\n//         () => console.log('No user found'),\n//         user => console.log('User:', user)\n//     ));\n"})}),"\n",(0,i.jsx)(e.h2,{id:"real-world-applications",children:"Real-World Applications"}),"\n",(0,i.jsx)(e.h3,{id:"form-validation-pipeline",children:"Form Validation Pipeline"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Complex form validation with Either monad\nconst validateForm = (formData) => {\n    const validateRequired = (field, value) =>\n        !value || value.trim() === '' \n            ? Either.left(`${field} is required`)\n            : Either.right(value.trim());\n    \n    const validateEmail = (email) =>\n        !/\\S+@\\S+\\.\\S+/.test(email)\n            ? Either.left('Invalid email format')\n            : Either.right(email);\n    \n    const validatePassword = (password) =>\n        password.length < 8\n            ? Either.left('Password must be at least 8 characters')\n            : Either.right(password);\n    \n    const validatePasswordMatch = (password, confirmPassword) =>\n        password !== confirmPassword\n            ? Either.left('Passwords do not match')\n            : Either.right(password);\n    \n    // Applicative validation (collect all errors)\n    const validateName = validateRequired('Name', formData.name);\n    const validateEmailField = validateRequired('Email', formData.email)\n        .flatMap(validateEmail);\n    const validatePasswordField = validateRequired('Password', formData.password)\n        .flatMap(validatePassword);\n    const validateConfirmPassword = validatePasswordField\n        .flatMap(password => \n            validatePasswordMatch(password, formData.confirmPassword)\n        );\n    \n    // Combine all validations\n    return validateName\n        .flatMap(name => \n            validateEmailField.flatMap(email =>\n                validateConfirmPassword.map(password => ({\n                    name,\n                    email,\n                    password,\n                    valid: true\n                }))\n            )\n        );\n};\n\n// Test the validation\nconst validForm = {\n    name: 'John Doe',\n    email: 'john@example.com',\n    password: 'secretpassword',\n    confirmPassword: 'secretpassword'\n};\n\nconst invalidForm = {\n    name: '',\n    email: 'invalid-email',\n    password: '123',\n    confirmPassword: '456'\n};\n\nconsole.log(validateForm(validForm).inspect());\nconsole.log(validateForm(invalidForm).inspect());\n"})}),"\n",(0,i.jsx)(e.h3,{id:"database-query-pipeline",children:"Database Query Pipeline"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Database operations with IO monad\nconst createConnection = () => IO.from(() => {\n    console.log('Creating database connection...');\n    return { connected: true, id: Math.random() };\n});\n\nconst executeQuery = (connection, query) => IO.from(() => {\n    console.log(`Executing query: ${query}`);\n    return {\n        results: [`Result for ${query}`],\n        affectedRows: 1\n    };\n});\n\nconst closeConnection = (connection) => IO.from(() => {\n    console.log(`Closing connection ${connection.id}`);\n    return 'Connection closed';\n});\n\n// Database operation pipeline\nconst databaseOperation = (query) =>\n    createConnection()\n        .flatMap(conn => \n            executeQuery(conn, query)\n                .flatMap(results => \n                    closeConnection(conn)\n                        .map(() => results)\n                )\n        );\n\n// Execute the pipeline\nconst result = databaseOperation('SELECT * FROM users').run();\nconsole.log('Query result:', result);\n"})}),"\n",(0,i.jsx)(e.h3,{id:"configuration-management",children:"Configuration Management"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// \u2705 Configuration with Reader monad\nconst createConfigReader = () => {\n    const getDbConfig = () => Reader.asks(env => env.database);\n    const getApiConfig = () => Reader.asks(env => env.api);\n    const getFeatureFlags = () => Reader.asks(env => env.features);\n    \n    const createDbConnection = () =>\n        getDbConfig()\n            .map(config => ({\n                host: config.host,\n                port: config.port,\n                connected: true\n            }));\n    \n    const createApiClient = () =>\n        getApiConfig()\n            .flatMap(config =>\n                getFeatureFlags()\n                    .map(features => ({\n                        baseUrl: config.baseUrl,\n                        timeout: config.timeout,\n                        features: features.api\n                    }))\n            );\n    \n    const initializeApp = () =>\n        createDbConnection()\n            .flatMap(db =>\n                createApiClient()\n                    .map(api => ({ database: db, api }))\n            );\n    \n    return { initializeApp };\n};\n\n// Environment configuration\nconst environment = {\n    database: { host: 'localhost', port: 5432 },\n    api: { baseUrl: 'https://api.example.com', timeout: 5000 },\n    features: { api: { caching: true, retry: true } }\n};\n\nconst configReader = createConfigReader();\nconst appConfig = configReader.initializeApp().run(environment);\nconsole.log('App configuration:', appConfig);\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"-key-takeaways",children:"\ud83c\udfaf Key Takeaways"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Monads are about composition"})," - chain operations while handling context"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Three laws govern monads"})," - left identity, right identity, and associativity"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"flatMap is the key"})," - it enables monadic composition and prevents nesting"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Each monad handles specific contexts"}),":","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Maybe: null/undefined values"}),"\n",(0,i.jsx)(e.li,{children:"Either: success/failure scenarios"}),"\n",(0,i.jsx)(e.li,{children:"IO: side effects"}),"\n",(0,i.jsx)(e.li,{children:"State: stateful computations"}),"\n",(0,i.jsx)(e.li,{children:"Reader: dependency injection"}),"\n",(0,i.jsx)(e.li,{children:"Writer: accumulation/logging"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Monad transformers"})," combine multiple monads for complex scenarios"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Real-world applications"})," include validation, database operations, and configuration management"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Separation of concerns"})," - business logic separate from context handling"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Abstraction power"})," - write generic code that works with any monad"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Monads are the most powerful abstraction in functional programming, enabling elegant composition of complex operations while maintaining purity and predictability."}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsxs)(e.em,{children:["Next: Learn about ",(0,i.jsx)(e.a,{href:"../Referential%20Programming/",children:"Referential Programming"})," to understand the mathematical foundations that make all of this possible."]})})]})}function u(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>o});var a=t(6540);const i={},r=a.createContext(i);function s(n){const e=a.useContext(r);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),a.createElement(r.Provider,{value:e},n.children)}}}]);