"use strict";(globalThis.webpackChunka=globalThis.webpackChunka||[]).push([[1749],{1176:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"functional-programming/pure-function-and-side-effect/README","title":"\ud83c\udfaf Pure Functions and Side Effects","description":"The foundation of functional programming: understanding and implementing pure functions while eliminating side effects","source":"@site/docs/functional-programming/pure-function-and-side-effect/README.md","sourceDirName":"functional-programming/pure-function-and-side-effect","slug":"/functional-programming/pure-function-and-side-effect/","permalink":"/docs/functional-programming/pure-function-and-side-effect/","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"\ud83c\udfd7\ufe0f Monads: Advanced Functional Patterns","permalink":"/docs/functional-programming/monads/"},"next":{"title":"\ud83d\udd12 Referential Transparency & Mathematical Foundations","permalink":"/docs/functional-programming/referential-programming/"}}');var i=t(4848),r=t(8453);const a={},o="\ud83c\udfaf Pure Functions and Side Effects",l={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"What are Pure Functions?",id:"what-are-pure-functions",level:2},{value:"Mathematical Foundation",id:"mathematical-foundation",level:3},{value:"Characteristics of Pure Functions",id:"characteristics-of-pure-functions",level:2},{value:"1. <strong>Deterministic Output</strong>",id:"1-deterministic-output",level:3},{value:"2. <strong>No Side Effects</strong>",id:"2-no-side-effects",level:3},{value:"3. <strong>No External Dependencies</strong>",id:"3-no-external-dependencies",level:3},{value:"4. <strong>Referential Transparency</strong>",id:"4-referential-transparency",level:3},{value:"Side Effects Explained",id:"side-effects-explained",level:2},{value:"Types of Side Effects",id:"types-of-side-effects",level:3},{value:"1. <strong>State Mutation</strong>",id:"1-state-mutation",level:4},{value:"2. <strong>Global State Modification</strong>",id:"2-global-state-modification",level:4},{value:"3. <strong>I/O Operations</strong>",id:"3-io-operations",level:4},{value:"Common Side Effects",id:"common-side-effects",level:2},{value:"\ud83d\udeab <strong>What to Avoid</strong>",id:"-what-to-avoid",level:3},{value:"Pure vs Impure Examples",id:"pure-vs-impure-examples",level:2},{value:"Example 1: String Manipulation",id:"example-1-string-manipulation",level:3},{value:"Example 2: Array Operations",id:"example-2-array-operations",level:3},{value:"Example 3: Object Updates",id:"example-3-object-updates",level:3},{value:"Immutability Techniques",id:"immutability-techniques",level:2},{value:"1. <strong>Primitive Values</strong>",id:"1-primitive-values",level:3},{value:"2. <strong>Arrays</strong>",id:"2-arrays",level:3},{value:"3. <strong>Objects</strong>",id:"3-objects",level:3},{value:"4. <strong>Using Immutability Libraries</strong>",id:"4-using-immutability-libraries",level:3},{value:"Testing Pure Functions",id:"testing-pure-functions",level:2},{value:"1. <strong>Simple Unit Tests</strong>",id:"1-simple-unit-tests",level:3},{value:"2. <strong>Property-Based Testing</strong>",id:"2-property-based-testing",level:3},{value:"3. <strong>Snapshot Testing</strong>",id:"3-snapshot-testing",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. <strong>Function Design Principles</strong>",id:"1-function-design-principles",level:3},{value:"2. <strong>Error Handling in Pure Functions</strong>",id:"2-error-handling-in-pure-functions",level:3},{value:"3. <strong>Pure Function Patterns</strong>",id:"3-pure-function-patterns",level:3},{value:"4. <strong>Performance Optimization</strong>",id:"4-performance-optimization",level:3},{value:"Advanced Concepts",id:"advanced-concepts",level:2},{value:"1. <strong>Recursion and Pure Functions</strong>",id:"1-recursion-and-pure-functions",level:3},{value:"2. <strong>Function Composition Utilities</strong>",id:"2-function-composition-utilities",level:3},{value:"3. <strong>Pure Function Testing Strategies</strong>",id:"3-pure-function-testing-strategies",level:3},{value:"\ud83c\udfaf Key Takeaways",id:"-key-takeaways",level:2}];function u(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"-pure-functions-and-side-effects",children:"\ud83c\udfaf Pure Functions and Side Effects"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"The foundation of functional programming: understanding and implementing pure functions while eliminating side effects"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#what-are-pure-functions",children:"What are Pure Functions?"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#characteristics-of-pure-functions",children:"Characteristics of Pure Functions"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#side-effects-explained",children:"Side Effects Explained"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#common-side-effects",children:"Common Side Effects"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#pure-vs-impure-examples",children:"Pure vs Impure Examples"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#immutability-techniques",children:"Immutability Techniques"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#testing-pure-functions",children:"Testing Pure Functions"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#best-practices",children:"Best Practices"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#advanced-concepts",children:"Advanced Concepts"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"what-are-pure-functions",children:"What are Pure Functions?"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.strong,{children:"pure function"})," is a function that, given the same input, will always return the same output and does not have any observable side effects. Pure functions are the building blocks of functional programming and make code more predictable, testable, and maintainable."]}),"\n",(0,i.jsx)(n.h3,{id:"mathematical-foundation",children:"Mathematical Foundation"}),"\n",(0,i.jsx)(n.p,{children:"Pure functions mirror mathematical functions:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"f(x) = x\xb2"})," always returns the same result for the same input"]}),"\n",(0,i.jsx)(n.li,{children:"The function doesn't modify anything outside its scope"}),"\n",(0,i.jsx)(n.li,{children:"The result depends only on the input parameters"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// Mathematical function representation\nconst square = x => x * x;\nconsole.log(square(4)); // Always 16\nconsole.log(square(4)); // Always 16\n"})}),"\n",(0,i.jsx)(n.h2,{id:"characteristics-of-pure-functions",children:"Characteristics of Pure Functions"}),"\n",(0,i.jsxs)(n.h3,{id:"1-deterministic-output",children:["1. ",(0,i.jsx)(n.strong,{children:"Deterministic Output"})]}),"\n",(0,i.jsx)(n.p,{children:"Given the same input, a pure function always produces the same output."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Pure - always returns same output for same input\nconst add = (a, b) => a + b;\nconsole.log(add(2, 3)); // Always 5\n\n// \u274c Impure - output varies each time\nconst addRandom = (a, b) => a + b + Math.random();\nconsole.log(addRandom(2, 3)); // Different each time\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"2-no-side-effects",children:["2. ",(0,i.jsx)(n.strong,{children:"No Side Effects"})]}),"\n",(0,i.jsx)(n.p,{children:"Pure functions don't modify anything outside their scope."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Pure - doesn't modify external state\nconst multiply = (a, b) => a * b;\n\n// \u274c Impure - modifies global variable\nlet total = 0;\nconst addToTotal = (value) => {\n    total += value; // Side effect!\n    return total;\n};\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"3-no-external-dependencies",children:["3. ",(0,i.jsx)(n.strong,{children:"No External Dependencies"})]}),"\n",(0,i.jsx)(n.p,{children:"Pure functions don't depend on external mutable state."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// \u274c Impure - depends on external variable\nlet multiplier = 2;\nconst multiplyByExternal = (x) => x * multiplier;\n\n// \u2705 Pure - all dependencies are parameters\nconst multiplyBy = (x, multiplier) => x * multiplier;\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"4-referential-transparency",children:["4. ",(0,i.jsx)(n.strong,{children:"Referential Transparency"})]}),"\n",(0,i.jsx)(n.p,{children:"Function calls can be replaced with their return values without changing program behavior."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Pure function\nconst double = x => x * 2;\n\n// These are equivalent:\nconst result1 = double(5) + double(3);\nconst result2 = 10 + 6; // Can substitute function calls with values\n"})}),"\n",(0,i.jsx)(n.h2,{id:"side-effects-explained",children:"Side Effects Explained"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.strong,{children:"side effect"})," is any application state change that is observable outside the called function. Side effects make code unpredictable and hard to test."]}),"\n",(0,i.jsx)(n.h3,{id:"types-of-side-effects",children:"Types of Side Effects"}),"\n",(0,i.jsxs)(n.h4,{id:"1-state-mutation",children:["1. ",(0,i.jsx)(n.strong,{children:"State Mutation"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// \u274c Mutating input parameters\nconst addItemImpure = (array, item) => {\n    array.push(item); // Modifies original array\n    return array;\n};\n\n// \u2705 Pure version - returns new array\nconst addItem = (array, item) => [...array, item];\n"})}),"\n",(0,i.jsxs)(n.h4,{id:"2-global-state-modification",children:["2. ",(0,i.jsx)(n.strong,{children:"Global State Modification"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// \u274c Modifying global state\nlet counter = 0;\nconst incrementCounter = () => ++counter;\n\n// \u2705 Pure version\nconst increment = (current) => current + 1;\n"})}),"\n",(0,i.jsxs)(n.h4,{id:"3-io-operations",children:["3. ",(0,i.jsx)(n.strong,{children:"I/O Operations"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// \u274c Side effects with I/O\nconst logAndDouble = (x) => {\n    console.log(`Doubling ${x}`); // I/O side effect\n    return x * 2;\n};\n\n// \u2705 Separate concerns\nconst double = x => x * 2;\nconst logResult = (value, result) => console.log(`${value} doubled is ${result}`);\n\n// Usage\nconst value = 5;\nconst result = double(value);\nlogResult(value, result);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"common-side-effects",children:"Common Side Effects"}),"\n",(0,i.jsxs)(n.h3,{id:"-what-to-avoid",children:["\ud83d\udeab ",(0,i.jsx)(n.strong,{children:"What to Avoid"})]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Modifying global variables or object properties"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Mutating function parameters"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Making HTTP requests or database calls"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Reading/writing files"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Printing to console or logging"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Using non-deterministic functions"})," (",(0,i.jsx)(n.code,{children:"Math.random()"}),", ",(0,i.jsx)(n.code,{children:"Date.now()"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Throwing exceptions"})," (unless handled within the function)"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Modifying DOM elements"})}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// \u274c Multiple side effects\nlet globalCount = 0;\nconst processData = (data) => {\n    console.log('Processing data...'); // I/O side effect\n    globalCount++; // Global state mutation\n    data.processed = true; // Parameter mutation\n    document.getElementById('status').textContent = 'Done'; // DOM manipulation\n    return data.value * Math.random(); // Non-deterministic\n};\n\n// \u2705 Pure version\nconst processValue = (value) => value * 2;\n\n// Side effects handled separately\nconst handleSideEffects = (data, result) => {\n    console.log('Processing data...');\n    updateGlobalCount();\n    updateDOM('status', 'Done');\n    return { ...data, processed: true, result };\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"pure-vs-impure-examples",children:"Pure vs Impure Examples"}),"\n",(0,i.jsx)(n.h3,{id:"example-1-string-manipulation",children:"Example 1: String Manipulation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// \u274c Impure - depends on external state\nlet prefix = 'Hello, ';\nconst greetImpure = (name) => prefix + name;\n\n// \u2705 Pure - all dependencies as parameters\nconst greet = (prefix, name) => prefix + name;\n\n// \u2705 Pure with default parameters\nconst greetDefault = (name, prefix = 'Hello, ') => prefix + name;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"example-2-array-operations",children:"Example 2: Array Operations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// \u274c Impure - mutates original array\nconst removeFirstImpure = (array) => {\n    array.shift(); // Modifies original array\n    return array;\n};\n\n// \u2705 Pure - returns new array\nconst removeFirst = (array) => array.slice(1);\n\n// \u2705 Alternative pure implementation\nconst removeFirstAlt = ([first, ...rest]) => rest;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"example-3-object-updates",children:"Example 3: Object Updates"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// \u274c Impure - mutates object\nconst updateAgeImpure = (person, newAge) => {\n    person.age = newAge; // Mutates original object\n    return person;\n};\n\n// \u2705 Pure - returns new object\nconst updateAge = (person, newAge) => ({ ...person, age: newAge });\n\n// \u2705 Pure nested update\nconst updateNestedPure = (obj, path, value) => {\n    if (path.length === 1) {\n        return { ...obj, [path[0]]: value };\n    }\n    const [head, ...tail] = path;\n    return {\n        ...obj,\n        [head]: updateNestedPure(obj[head], tail, value)\n    };\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"immutability-techniques",children:"Immutability Techniques"}),"\n",(0,i.jsxs)(n.h3,{id:"1-primitive-values",children:["1. ",(0,i.jsx)(n.strong,{children:"Primitive Values"})]}),"\n",(0,i.jsx)(n.p,{children:"Primitives are immutable by nature in JavaScript."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"const name = 'John';\nconst newName = name.toUpperCase(); // Returns new string\nconsole.log(name); // Still 'John'\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"2-arrays",children:["2. ",(0,i.jsx)(n.strong,{children:"Arrays"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Immutable array operations\nconst numbers = [1, 2, 3, 4, 5];\n\n// Add elements\nconst withNewElement = [...numbers, 6];\nconst withElementAtStart = [0, ...numbers];\n\n// Remove elements\nconst withoutFirst = numbers.slice(1);\nconst withoutLast = numbers.slice(0, -1);\nconst withoutIndex = [...numbers.slice(0, 2), ...numbers.slice(3)];\n\n// Update elements\nconst withUpdatedElement = numbers.map((n, i) => i === 2 ? n * 10 : n);\n\n// Complex transformations\nconst processedNumbers = numbers\n    .filter(n => n > 2)\n    .map(n => n * 2)\n    .reduce((acc, n) => [...acc, n], []);\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"3-objects",children:["3. ",(0,i.jsx)(n.strong,{children:"Objects"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Immutable object operations\nconst person = { name: 'John', age: 30, city: 'Boston' };\n\n// Add property\nconst withEmail = { ...person, email: 'john@example.com' };\n\n// Update property\nconst olderPerson = { ...person, age: person.age + 1 };\n\n// Remove property\nconst { city, ...withoutCity } = person;\n\n// Nested updates\nconst userProfile = {\n    user: {\n        personal: { name: 'John', age: 30 },\n        preferences: { theme: 'dark', language: 'en' }\n    }\n};\n\nconst updatedProfile = {\n    ...userProfile,\n    user: {\n        ...userProfile.user,\n        personal: {\n            ...userProfile.user.personal,\n            age: 31\n        }\n    }\n};\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"4-using-immutability-libraries",children:["4. ",(0,i.jsx)(n.strong,{children:"Using Immutability Libraries"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// Using Immutable.js\nimport { Map, List } from 'immutable';\n\nconst immutableMap = Map({ a: 1, b: 2, c: 3 });\nconst updatedMap = immutableMap.set('b', 10); // Returns new Map\n\nconst immutableList = List([1, 2, 3, 4]);\nconst updatedList = immutableList.push(5); // Returns new List\n\n// Using Immer\nimport produce from 'immer';\n\nconst state = {\n    users: [\n        { id: 1, name: 'John', posts: [] }\n    ]\n};\n\nconst newState = produce(state, draft => {\n    draft.users[0].posts.push({ title: 'New Post', content: '...' });\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"testing-pure-functions",children:"Testing Pure Functions"}),"\n",(0,i.jsx)(n.p,{children:"Pure functions are incredibly easy to test because they're predictable and isolated."}),"\n",(0,i.jsxs)(n.h3,{id:"1-simple-unit-tests",children:["1. ",(0,i.jsx)(n.strong,{children:"Simple Unit Tests"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// Pure function to test\nconst calculateTotal = (items) => \n    items.reduce((total, item) => total + (item.price * item.quantity), 0);\n\n// Tests\ndescribe('calculateTotal', () => {\n    test('should calculate total for multiple items', () => {\n        const items = [\n            { price: 10, quantity: 2 },\n            { price: 5, quantity: 3 }\n        ];\n        expect(calculateTotal(items)).toBe(35);\n    });\n    \n    test('should return 0 for empty array', () => {\n        expect(calculateTotal([])).toBe(0);\n    });\n    \n    test('should handle single item', () => {\n        const items = [{ price: 15, quantity: 1 }];\n        expect(calculateTotal(items)).toBe(15);\n    });\n});\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"2-property-based-testing",children:["2. ",(0,i.jsx)(n.strong,{children:"Property-Based Testing"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// Using a property-based testing library like fast-check\nconst fc = require('fast-check');\n\n// Property: adding zero should not change the result\nfc.assert(fc.property(fc.integer(), (n) => {\n    return add(n, 0) === n;\n}));\n\n// Property: addition should be commutative\nfc.assert(fc.property(fc.integer(), fc.integer(), (a, b) => {\n    return add(a, b) === add(b, a);\n}));\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"3-snapshot-testing",children:["3. ",(0,i.jsx)(n.strong,{children:"Snapshot Testing"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// Complex pure function\nconst formatUserData = (users) => \n    users\n        .filter(user => user.active)\n        .map(user => ({\n            id: user.id,\n            name: user.name.toUpperCase(),\n            initials: user.name.split(' ').map(n => n[0]).join(''),\n            memberSince: new Date(user.createdAt).getFullYear()\n        }))\n        .sort((a, b) => a.name.localeCompare(b.name));\n\n// Snapshot test\ntest('should format user data correctly', () => {\n    const users = [/* test data */];\n    expect(formatUserData(users)).toMatchSnapshot();\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.h3,{id:"1-function-design-principles",children:["1. ",(0,i.jsx)(n.strong,{children:"Function Design Principles"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Single Responsibility\nconst validateEmail = (email) => /\\S+@\\S+\\.\\S+/.test(email);\nconst formatEmail = (email) => email.toLowerCase().trim();\nconst hashEmail = (email) => btoa(email); // Base64 encoding for example\n\n// \u2705 Composition over single complex function\nconst processEmail = (email) => \n    pipe(formatEmail, validateEmail, hashEmail)(email);\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"2-error-handling-in-pure-functions",children:["2. ",(0,i.jsx)(n.strong,{children:"Error Handling in Pure Functions"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Return error information instead of throwing\nconst divide = (a, b) => {\n    if (b === 0) {\n        return { success: false, error: 'Division by zero' };\n    }\n    return { success: true, result: a / b };\n};\n\n// \u2705 Using Maybe monad for error handling\nconst safeDivide = (a, b) => \n    b === 0 ? Maybe.none() : Maybe.some(a / b);\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"3-pure-function-patterns",children:["3. ",(0,i.jsx)(n.strong,{children:"Pure Function Patterns"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Factory functions for configuration\nconst createValidator = (rules) => (data) => \n    rules.every(rule => rule(data));\n\nconst userValidator = createValidator([\n    user => user.name && user.name.length > 0,\n    user => user.email && validateEmail(user.email),\n    user => user.age && user.age >= 18\n]);\n\n// \u2705 Curried functions for partial application\nconst curry = (fn) => (...args) => \n    args.length >= fn.length \n        ? fn(...args)\n        : (...nextArgs) => curry(fn)(...args, ...nextArgs);\n\nconst multiply = curry((a, b, c) => a * b * c);\nconst double = multiply(2);\nconst quadruple = multiply(2, 2);\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"4-performance-optimization",children:["4. ",(0,i.jsx)(n.strong,{children:"Performance Optimization"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Memoization for expensive pure functions\nconst memoize = (fn) => {\n    const cache = new Map();\n    return (...args) => {\n        const key = JSON.stringify(args);\n        if (cache.has(key)) {\n            return cache.get(key);\n        }\n        const result = fn(...args);\n        cache.set(key, result);\n        return result;\n    };\n};\n\nconst expensiveCalculation = memoize((n) => {\n    console.log(`Computing for ${n}`);\n    return n * n * n;\n});\n\n// \u2705 Lazy evaluation\nconst lazy = (fn) => {\n    let computed = false;\n    let result;\n    return () => {\n        if (!computed) {\n            result = fn();\n            computed = true;\n        }\n        return result;\n    };\n};\n\nconst lazyValue = lazy(() => expensiveCalculation(100));\n"})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-concepts",children:"Advanced Concepts"}),"\n",(0,i.jsxs)(n.h3,{id:"1-recursion-and-pure-functions",children:["1. ",(0,i.jsx)(n.strong,{children:"Recursion and Pure Functions"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Pure recursive functions\nconst factorial = (n) => \n    n <= 1 ? 1 : n * factorial(n - 1);\n\n// \u2705 Tail-recursive version (more memory efficient)\nconst factorialTail = (n, acc = 1) => \n    n <= 1 ? acc : factorialTail(n - 1, n * acc);\n\n// \u2705 Pure tree traversal\nconst mapTree = (fn, tree) => {\n    if (!tree || typeof tree !== 'object') {\n        return fn(tree);\n    }\n    \n    if (Array.isArray(tree)) {\n        return tree.map(child => mapTree(fn, child));\n    }\n    \n    return Object.keys(tree).reduce((acc, key) => ({\n        ...acc,\n        [key]: mapTree(fn, tree[key])\n    }), {});\n};\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"2-function-composition-utilities",children:["2. ",(0,i.jsx)(n.strong,{children:"Function Composition Utilities"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Advanced composition utilities\nconst pipe = (...fns) => (value) => fns.reduce((acc, fn) => fn(acc), value);\nconst compose = (...fns) => (value) => fns.reduceRight((acc, fn) => fn(acc), value);\n\n// \u2705 Async composition\nconst pipeAsync = (...fns) => (value) => \n    fns.reduce((acc, fn) => acc.then(fn), Promise.resolve(value));\n\n// \u2705 Conditional composition\nconst when = (predicate, fn) => (value) => \n    predicate(value) ? fn(value) : value;\n\nconst unless = (predicate, fn) => (value) => \n    !predicate(value) ? fn(value) : value;\n\n// Usage\nconst processNumber = pipe(\n    x => x * 2,\n    when(x => x > 10, x => x + 5),\n    unless(x => x % 2 === 0, x => x + 1)\n);\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"3-pure-function-testing-strategies",children:["3. ",(0,i.jsx)(n.strong,{children:"Pure Function Testing Strategies"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Contract testing\nconst testFunction = (fn, contracts) => {\n    contracts.forEach(({ input, expectedOutput, description }) => {\n        const result = fn(...input);\n        console.assert(\n            JSON.stringify(result) === JSON.stringify(expectedOutput),\n            `${description}: Expected ${expectedOutput}, got ${result}`\n        );\n    });\n};\n\n// Define contracts\nconst addContracts = [\n    { input: [2, 3], expectedOutput: 5, description: 'Add positive numbers' },\n    { input: [-1, 1], expectedOutput: 0, description: 'Add negative and positive' },\n    { input: [0, 0], expectedOutput: 0, description: 'Add zeros' }\n];\n\ntestFunction(add, addContracts);\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"-key-takeaways",children:"\ud83c\udfaf Key Takeaways"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pure functions are predictable"})," - same input always produces same output"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Side effects make code unpredictable"})," - avoid them in functional code"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Immutability is crucial"})," - never modify existing data structures"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pure functions are easy to test"})," - no setup or mocking required"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compose pure functions"})," - build complex behavior from simple functions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Separate side effects"})," - handle them at the boundaries of your system"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use proper error handling"})," - return errors instead of throwing them"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Leverage memoization"})," - cache results of expensive pure functions"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Pure functions form the foundation of functional programming. Master them, and you'll write more reliable, maintainable, and testable code."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.em,{children:["Next: Learn about ",(0,i.jsx)(n.a,{href:"../function%20&%20composition/",children:"Function Composition"})," to combine pure functions into powerful abstractions."]}),"\nvalues.reduce((acc, value) => acc + value, 0);"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"\n---\n\n*Pure functions are the foundation of reliable, testable, and maintainable functional programming.*\n"})})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(6540);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);