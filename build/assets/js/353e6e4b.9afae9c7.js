"use strict";(globalThis.webpackChunka=globalThis.webpackChunka||[]).push([[9314],{8453:(e,r,t)=>{t.d(r,{R:()=>i,x:()=>o});var n=t(6540);const s={},a=n.createContext(s);function i(e){const r=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),n.createElement(a.Provider,{value:r},e.children)}},9495:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"design-pattern/behavioral/strategy","title":"Strategy Pattern \ud83c\udfaf","description":"Definition: The Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it.","source":"@site/docs/design-pattern/behavioral/strategy.md","sourceDirName":"design-pattern/behavioral","slug":"/design-pattern/behavioral/strategy","permalink":"/docs/design-pattern/behavioral/strategy","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"State Pattern \ud83c\udf9b\ufe0f","permalink":"/docs/design-pattern/behavioral/state"},"next":{"title":"Template Method Pattern \ud83d\udccb","permalink":"/docs/design-pattern/behavioral/template-method"}}');var s=t(4848),a=t(8453);const i={},o="Strategy Pattern \ud83c\udfaf",l={},c=[{value:"\ud83c\udfaf Intent",id:"-intent",level:2},{value:"\ud83e\udd14 Problem",id:"-problem",level:2},{value:"\ud83d\udca1 Solution",id:"-solution",level:2},{value:"\ud83c\udfd7\ufe0f Structure",id:"\ufe0f-structure",level:2},{value:"\ud83d\udcbb Code Example",id:"-code-example",level:2},{value:"Basic Implementation",id:"basic-implementation",level:3},{value:"\ud83c\udf1f Real-World Examples",id:"-real-world-examples",level:2},{value:"1. Payment Processing System",id:"1-payment-processing-system",level:3},{value:"2. Data Validation Strategies",id:"2-data-validation-strategies",level:3},{value:"3. Compression Strategies",id:"3-compression-strategies",level:3},{value:"\u2705 Pros",id:"-pros",level:2},{value:"\u274c Cons",id:"-cons",level:2},{value:"\ud83c\udfaf When to Use",id:"-when-to-use",level:2},{value:"\ud83d\udd04 Common Variations",id:"-common-variations",level:2},{value:"1. <strong>Strategy with State</strong>",id:"1-strategy-with-state",level:3},{value:"2. <strong>Strategy Factory</strong>",id:"2-strategy-factory",level:3},{value:"3. <strong>Async Strategies</strong>",id:"3-async-strategies",level:3},{value:"\ud83d\udd17 Related Patterns",id:"-related-patterns",level:2},{value:"\ud83d\udcc8 Performance Considerations",id:"-performance-considerations",level:2},{value:"\ud83d\udcda Further Reading",id:"-further-reading",level:2}];function d(e){const r={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"strategy-pattern-",children:"Strategy Pattern \ud83c\udfaf"})}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Definition"}),": The Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it."]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"-intent",children:"\ud83c\udfaf Intent"}),"\n",(0,s.jsx)(r.p,{children:"Enable selecting an algorithm's behavior at runtime by encapsulating algorithms in separate classes and making them interchangeable."}),"\n",(0,s.jsx)(r.h2,{id:"-problem",children:"\ud83e\udd14 Problem"}),"\n",(0,s.jsx)(r.p,{children:"You have multiple ways of performing a task (like sorting, payment processing, or data validation) and you want to:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Switch between them at runtime"}),"\n",(0,s.jsx)(r.li,{children:"Add new algorithms without modifying existing code"}),"\n",(0,s.jsx)(r.li,{children:"Avoid massive if-else or switch statements"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"For example, an e-commerce app might support multiple payment methods: credit card, PayPal, cryptocurrency, etc. Without the Strategy pattern, you'd end up with a massive switch statement that violates the Open-Closed Principle."}),"\n",(0,s.jsx)(r.h2,{id:"-solution",children:"\ud83d\udca1 Solution"}),"\n",(0,s.jsx)(r.p,{children:"The Strategy pattern suggests extracting all different algorithms into separate classes called strategies. The original class (context) gets a field for storing a reference to one of the strategies and delegates the work to the linked strategy object."}),"\n",(0,s.jsx)(r.h2,{id:"\ufe0f-structure",children:"\ud83c\udfd7\ufe0f Structure"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"Context\r\n\u251c\u2500\u2500 strategy: Strategy\r\n\u251c\u2500\u2500 setStrategy(strategy: Strategy)\r\n\u2514\u2500\u2500 executeStrategy()\r\n\r\nStrategy (interface)\r\n\u2514\u2500\u2500 execute()\r\n\r\nConcreteStrategyA implements Strategy\r\n\u2514\u2500\u2500 execute()\r\n\r\nConcreteStrategyB implements Strategy  \r\n\u2514\u2500\u2500 execute()\r\n\r\nConcreteStrategyC implements Strategy\r\n\u2514\u2500\u2500 execute()\n"})}),"\n",(0,s.jsx)(r.h2,{id:"-code-example",children:"\ud83d\udcbb Code Example"}),"\n",(0,s.jsx)(r.h3,{id:"basic-implementation",children:"Basic Implementation"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// Strategy interface\r\nclass Strategy {\r\n  execute(data) {\r\n    throw new Error("execute() method must be implemented");\r\n  }\r\n}\r\n\r\n// Concrete Strategies\r\nclass QuickSort extends Strategy {\r\n  execute(data) {\r\n    console.log("Sorting using QuickSort algorithm");\r\n    return this.quickSort([...data]);\r\n  }\r\n  \r\n  quickSort(arr) {\r\n    if (arr.length <= 1) return arr;\r\n    \r\n    const pivot = arr[Math.floor(arr.length / 2)];\r\n    const left = arr.filter(x => x < pivot);\r\n    const middle = arr.filter(x => x === pivot);\r\n    const right = arr.filter(x => x > pivot);\r\n    \r\n    return [...this.quickSort(left), ...middle, ...this.quickSort(right)];\r\n  }\r\n}\r\n\r\nclass BubbleSort extends Strategy {\r\n  execute(data) {\r\n    console.log("Sorting using BubbleSort algorithm");\r\n    const arr = [...data];\r\n    \r\n    for (let i = 0; i < arr.length - 1; i++) {\r\n      for (let j = 0; j < arr.length - i - 1; j++) {\r\n        if (arr[j] > arr[j + 1]) {\r\n          [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\r\n        }\r\n      }\r\n    }\r\n    return arr;\r\n  }\r\n}\r\n\r\nclass MergeSort extends Strategy {\r\n  execute(data) {\r\n    console.log("Sorting using MergeSort algorithm");\r\n    return this.mergeSort([...data]);\r\n  }\r\n  \r\n  mergeSort(arr) {\r\n    if (arr.length <= 1) return arr;\r\n    \r\n    const mid = Math.floor(arr.length / 2);\r\n    const left = this.mergeSort(arr.slice(0, mid));\r\n    const right = this.mergeSort(arr.slice(mid));\r\n    \r\n    return this.merge(left, right);\r\n  }\r\n  \r\n  merge(left, right) {\r\n    const result = [];\r\n    let i = 0, j = 0;\r\n    \r\n    while (i < left.length && j < right.length) {\r\n      if (left[i] <= right[j]) {\r\n        result.push(left[i++]);\r\n      } else {\r\n        result.push(right[j++]);\r\n      }\r\n    }\r\n    \r\n    return result.concat(left.slice(i), right.slice(j));\r\n  }\r\n}\r\n\r\n// Context\r\nclass Sorter {\r\n  constructor(strategy) {\r\n    this.strategy = strategy;\r\n  }\r\n  \r\n  setStrategy(strategy) {\r\n    this.strategy = strategy;\r\n  }\r\n  \r\n  sort(data) {\r\n    if (!this.strategy) {\r\n      throw new Error("No sorting strategy set");\r\n    }\r\n    return this.strategy.execute(data);\r\n  }\r\n}\r\n\r\n// Usage\r\nconst data = [64, 34, 25, 12, 22, 11, 90];\r\nconst sorter = new Sorter(new QuickSort());\r\n\r\nconsole.log("Original:", data);\r\nconsole.log("Sorted:", sorter.sort(data));\r\n\r\n// Change strategy at runtime\r\nsorter.setStrategy(new BubbleSort());\r\nconsole.log("Sorted with Bubble Sort:", sorter.sort(data));\n'})}),"\n",(0,s.jsx)(r.h2,{id:"-real-world-examples",children:"\ud83c\udf1f Real-World Examples"}),"\n",(0,s.jsx)(r.h3,{id:"1-payment-processing-system",children:"1. Payment Processing System"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// Payment strategies\r\nclass PaymentStrategy {\r\n  pay(amount) {\r\n    throw new Error("pay() method must be implemented");\r\n  }\r\n}\r\n\r\nclass CreditCardPayment extends PaymentStrategy {\r\n  constructor(cardNumber, expiryDate, cvv) {\r\n    super();\r\n    this.cardNumber = cardNumber;\r\n    this.expiryDate = expiryDate;\r\n    this.cvv = cvv;\r\n  }\r\n  \r\n  pay(amount) {\r\n    console.log(`\ud83d\udcb3 Processing $${amount} via Credit Card`);\r\n    console.log(`Card: ****-****-****-${this.cardNumber.slice(-4)}`);\r\n    \r\n    // Simulate payment processing\r\n    if (this.validateCard()) {\r\n      console.log("\u2705 Payment successful!");\r\n      return { success: true, transactionId: `CC_${Date.now()}` };\r\n    }\r\n    return { success: false, error: "Invalid card details" };\r\n  }\r\n  \r\n  validateCard() {\r\n    return this.cardNumber.length === 16 && this.cvv.length === 3;\r\n  }\r\n}\r\n\r\nclass PayPalPayment extends PaymentStrategy {\r\n  constructor(email, password) {\r\n    super();\r\n    this.email = email;\r\n    this.password = password;\r\n  }\r\n  \r\n  pay(amount) {\r\n    console.log(`\ud83c\udd7f\ufe0f Processing $${amount} via PayPal`);\r\n    console.log(`Account: ${this.email}`);\r\n    \r\n    if (this.authenticate()) {\r\n      console.log("\u2705 Payment successful!");\r\n      return { success: true, transactionId: `PP_${Date.now()}` };\r\n    }\r\n    return { success: false, error: "Authentication failed" };\r\n  }\r\n  \r\n  authenticate() {\r\n    return this.email.includes(\'@\') && this.password.length >= 6;\r\n  }\r\n}\r\n\r\nclass CryptocurrencyPayment extends PaymentStrategy {\r\n  constructor(walletAddress, privateKey, currency) {\r\n    super();\r\n    this.walletAddress = walletAddress;\r\n    this.privateKey = privateKey;\r\n    this.currency = currency;\r\n  }\r\n  \r\n  pay(amount) {\r\n    console.log(`\u20bf Processing $${amount} via ${this.currency}`);\r\n    console.log(`Wallet: ${this.walletAddress.slice(0, 6)}...${this.walletAddress.slice(-4)}`);\r\n    \r\n    if (this.validateWallet()) {\r\n      console.log("\u2705 Transaction broadcasted to blockchain!");\r\n      return { success: true, transactionId: `${this.currency}_${Date.now()}` };\r\n    }\r\n    return { success: false, error: "Invalid wallet" };\r\n  }\r\n  \r\n  validateWallet() {\r\n    return this.walletAddress.length >= 26;\r\n  }\r\n}\r\n\r\n// Shopping cart context\r\nclass ShoppingCart {\r\n  constructor() {\r\n    this.items = [];\r\n    this.paymentStrategy = null;\r\n  }\r\n  \r\n  addItem(item, price) {\r\n    this.items.push({ item, price });\r\n  }\r\n  \r\n  setPaymentStrategy(strategy) {\r\n    this.paymentStrategy = strategy;\r\n  }\r\n  \r\n  getTotal() {\r\n    return this.items.reduce((total, item) => total + item.price, 0);\r\n  }\r\n  \r\n  checkout() {\r\n    if (!this.paymentStrategy) {\r\n      console.log("\u274c Please select a payment method");\r\n      return false;\r\n    }\r\n    \r\n    const total = this.getTotal();\r\n    console.log("\\n\ud83d\uded2 Order Summary:");\r\n    this.items.forEach(item => {\r\n      console.log(`   ${item.item}: $${item.price}`);\r\n    });\r\n    console.log(`   Total: $${total}`);\r\n    console.log("\u2500".repeat(30));\r\n    \r\n    return this.paymentStrategy.pay(total);\r\n  }\r\n}\r\n\r\n// Usage\r\nconst cart = new ShoppingCart();\r\ncart.addItem("Laptop", 999.99);\r\ncart.addItem("Mouse", 29.99);\r\n\r\n// Try different payment methods\r\nconst creditCard = new CreditCardPayment("1234567812345678", "12/25", "123");\r\nconst paypal = new PayPalPayment("user@example.com", "password123");\r\nconst bitcoin = new CryptocurrencyPayment("1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa", "private_key", "Bitcoin");\r\n\r\ncart.setPaymentStrategy(creditCard);\r\ncart.checkout();\r\n\r\ncart.setPaymentStrategy(paypal);\r\ncart.checkout();\r\n\r\ncart.setPaymentStrategy(bitcoin);\r\ncart.checkout();\n'})}),"\n",(0,s.jsx)(r.h3,{id:"2-data-validation-strategies",children:"2. Data Validation Strategies"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'class ValidationStrategy {\r\n  validate(data) {\r\n    throw new Error("validate() method must be implemented");\r\n  }\r\n}\r\n\r\nclass EmailValidation extends ValidationStrategy {\r\n  validate(email) {\r\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n    const isValid = emailRegex.test(email);\r\n    \r\n    return {\r\n      isValid,\r\n      message: isValid ? "Valid email" : "Invalid email format"\r\n    };\r\n  }\r\n}\r\n\r\nclass PasswordValidation extends ValidationStrategy {\r\n  constructor(minLength = 8) {\r\n    super();\r\n    this.minLength = minLength;\r\n  }\r\n  \r\n  validate(password) {\r\n    const hasMinLength = password.length >= this.minLength;\r\n    const hasUpperCase = /[A-Z]/.test(password);\r\n    const hasLowerCase = /[a-z]/.test(password);\r\n    const hasNumbers = /\\d/.test(password);\r\n    const hasSpecialChar = /[!@#$%^&*()_+\\-=\\[\\]{};\':"\\\\|,.<>?]/.test(password);\r\n    \r\n    const isValid = hasMinLength && hasUpperCase && hasLowerCase && hasNumbers && hasSpecialChar;\r\n    \r\n    const issues = [];\r\n    if (!hasMinLength) issues.push(`minimum ${this.minLength} characters`);\r\n    if (!hasUpperCase) issues.push("uppercase letter");\r\n    if (!hasLowerCase) issues.push("lowercase letter");\r\n    if (!hasNumbers) issues.push("number");\r\n    if (!hasSpecialChar) issues.push("special character");\r\n    \r\n    return {\r\n      isValid,\r\n      message: isValid ? "Strong password" : `Password must contain: ${issues.join(", ")}`\r\n    };\r\n  }\r\n}\r\n\r\nclass PhoneValidation extends ValidationStrategy {\r\n  validate(phone) {\r\n    const phoneRegex = /^\\+?[\\d\\s\\-\\(\\)]{10,}$/;\r\n    const isValid = phoneRegex.test(phone);\r\n    \r\n    return {\r\n      isValid,\r\n      message: isValid ? "Valid phone number" : "Invalid phone number format"\r\n    };\r\n  }\r\n}\r\n\r\nclass FormValidator {\r\n  constructor() {\r\n    this.strategies = new Map();\r\n  }\r\n  \r\n  addValidation(field, strategy) {\r\n    this.strategies.set(field, strategy);\r\n  }\r\n  \r\n  validate(formData) {\r\n    const results = {};\r\n    \r\n    for (const [field, strategy] of this.strategies) {\r\n      if (formData.hasOwnProperty(field)) {\r\n        results[field] = strategy.validate(formData[field]);\r\n      }\r\n    }\r\n    \r\n    return results;\r\n  }\r\n}\r\n\r\n// Usage\r\nconst validator = new FormValidator();\r\nvalidator.addValidation(\'email\', new EmailValidation());\r\nvalidator.addValidation(\'password\', new PasswordValidation(10));\r\nvalidator.addValidation(\'phone\', new PhoneValidation());\r\n\r\nconst formData = {\r\n  email: "user@example.com",\r\n  password: "Weak123",\r\n  phone: "+1-555-123-4567"\r\n};\r\n\r\nconst results = validator.validate(formData);\r\nconsole.log("Validation Results:", results);\n'})}),"\n",(0,s.jsx)(r.h3,{id:"3-compression-strategies",children:"3. Compression Strategies"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'class CompressionStrategy {\r\n  compress(data) {\r\n    throw new Error("compress() method must be implemented");\r\n  }\r\n  \r\n  decompress(data) {\r\n    throw new Error("decompress() method must be implemented");\r\n  }\r\n}\r\n\r\nclass ZipCompression extends CompressionStrategy {\r\n  compress(data) {\r\n    console.log("\ud83d\udddc\ufe0f  Compressing with ZIP algorithm");\r\n    // Simulate ZIP compression\r\n    const compressed = `ZIP_COMPRESSED[${data.length}]`;\r\n    console.log(`Original: ${data.length} bytes \u2192 Compressed: ${compressed.length} bytes`);\r\n    return compressed;\r\n  }\r\n  \r\n  decompress(compressedData) {\r\n    console.log("\ud83d\udce4 Decompressing ZIP data");\r\n    return compressedData.replace("ZIP_COMPRESSED[", "").replace("]", "");\r\n  }\r\n}\r\n\r\nclass GzipCompression extends CompressionStrategy {\r\n  compress(data) {\r\n    console.log("\ud83d\udddc\ufe0f  Compressing with GZIP algorithm");\r\n    const compressed = `GZIP_COMPRESSED[${data.length}]`;\r\n    console.log(`Original: ${data.length} bytes \u2192 Compressed: ${compressed.length} bytes`);\r\n    return compressed;\r\n  }\r\n  \r\n  decompress(compressedData) {\r\n    console.log("\ud83d\udce4 Decompressing GZIP data");\r\n    return compressedData.replace("GZIP_COMPRESSED[", "").replace("]", "");\r\n  }\r\n}\r\n\r\nclass RarCompression extends CompressionStrategy {\r\n  compress(data) {\r\n    console.log("\ud83d\udddc\ufe0f  Compressing with RAR algorithm");\r\n    const compressed = `RAR_COMPRESSED[${data.length}]`;\r\n    console.log(`Original: ${data.length} bytes \u2192 Compressed: ${compressed.length} bytes`);\r\n    return compressed;\r\n  }\r\n  \r\n  decompress(compressedData) {\r\n    console.log("\ud83d\udce4 Decompressing RAR data");\r\n    return compressedData.replace("RAR_COMPRESSED[", "").replace("]", "");\r\n  }\r\n}\r\n\r\nclass FileCompressor {\r\n  constructor(strategy) {\r\n    this.strategy = strategy;\r\n  }\r\n  \r\n  setStrategy(strategy) {\r\n    this.strategy = strategy;\r\n  }\r\n  \r\n  compressFile(filename, data) {\r\n    console.log(`\\n\ud83d\udcc1 Processing file: ${filename}`);\r\n    return this.strategy.compress(data);\r\n  }\r\n  \r\n  decompressFile(compressedData) {\r\n    return this.strategy.decompress(compressedData);\r\n  }\r\n}\r\n\r\n// Usage\r\nconst data = "This is a sample file content that needs to be compressed...";\r\nconst compressor = new FileCompressor(new ZipCompression());\r\n\r\n// Compress with ZIP\r\nlet compressed = compressor.compressFile("document.txt", data);\r\n\r\n// Switch to GZIP\r\ncompressor.setStrategy(new GzipCompression());\r\ncompressed = compressor.compressFile("document.txt", data);\r\n\r\n// Switch to RAR\r\ncompressor.setStrategy(new RarCompression());\r\ncompressed = compressor.compressFile("document.txt", data);\n'})}),"\n",(0,s.jsx)(r.h2,{id:"-pros",children:"\u2705 Pros"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Open/Closed Principle"}),": You can introduce new strategies without changing existing code"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Runtime Algorithm Selection"}),": You can switch algorithms at runtime"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Elimination of Conditionals"}),": Replaces large switch statements or if-else chains"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Isolation of Implementation Details"}),": Each strategy encapsulates its algorithm"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Code Reusability"}),": Strategies can be reused across different contexts"]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"-cons",children:"\u274c Cons"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Increased Number of Classes"}),": Can result in many small classes"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Client Awareness"}),": Clients must be aware of different strategies to choose the appropriate one"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Communication Overhead"}),": Context and strategies might need to exchange data"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Strategy Interface Complexity"}),": If strategies have very different requirements, the interface might become complex"]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"-when-to-use",children:"\ud83c\udfaf When to Use"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Multiple Algorithm Variants"}),": When you have multiple ways of performing a task"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Runtime Selection"}),": When you want to choose algorithms at runtime"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Avoiding Conditionals"}),": When you want to eliminate large conditional statements"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Plugin Architecture"}),": When building systems that support plugins or extensions"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"A/B Testing"}),": When you need to test different implementations"]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"-common-variations",children:"\ud83d\udd04 Common Variations"}),"\n",(0,s.jsxs)(r.h3,{id:"1-strategy-with-state",children:["1. ",(0,s.jsx)(r.strong,{children:"Strategy with State"})]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'class StatefulStrategy extends Strategy {\r\n  constructor() {\r\n    super();\r\n    this.state = {};\r\n  }\r\n  \r\n  execute(data) {\r\n    // Use and modify internal state\r\n    this.state.executionCount = (this.state.executionCount || 0) + 1;\r\n    return this.process(data);\r\n  }\r\n  \r\n  process(data) {\r\n    throw new Error("process() method must be implemented");\r\n  }\r\n}\n'})}),"\n",(0,s.jsxs)(r.h3,{id:"2-strategy-factory",children:["2. ",(0,s.jsx)(r.strong,{children:"Strategy Factory"})]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:"class StrategyFactory {\r\n  static createStrategy(type) {\r\n    switch(type) {\r\n      case 'quick': return new QuickSort();\r\n      case 'bubble': return new BubbleSort();\r\n      case 'merge': return new MergeSort();\r\n      default: throw new Error(`Unknown strategy type: ${type}`);\r\n    }\r\n  }\r\n}\r\n\r\n// Usage\r\nconst strategy = StrategyFactory.createStrategy('quick');\r\nconst sorter = new Sorter(strategy);\n"})}),"\n",(0,s.jsxs)(r.h3,{id:"3-async-strategies",children:["3. ",(0,s.jsx)(r.strong,{children:"Async Strategies"})]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'class AsyncStrategy {\r\n  async execute(data) {\r\n    throw new Error("execute() method must be implemented");\r\n  }\r\n}\r\n\r\nclass AsyncContext {\r\n  constructor(strategy) {\r\n    this.strategy = strategy;\r\n  }\r\n  \r\n  async performOperation(data) {\r\n    return await this.strategy.execute(data);\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(r.h2,{id:"-related-patterns",children:"\ud83d\udd17 Related Patterns"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"State"}),": Both patterns use composition and delegation, but Strategy focuses on algorithms while State focuses on behavior changes"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Template Method"}),": Both patterns deal with varying algorithms, but Strategy uses composition while Template Method uses inheritance"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Bridge"}),": Similar structure, but Bridge separates interface from implementation while Strategy makes algorithms interchangeable"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Factory Method"}),": Often used together to create appropriate strategies"]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"-performance-considerations",children:"\ud83d\udcc8 Performance Considerations"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Memory Usage"}),": Each strategy creates a separate object"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Strategy Switching Cost"}),": Changing strategies has minimal overhead"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Algorithm Complexity"}),": Choose strategies based on data size and performance requirements"]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"-further-reading",children:"\ud83d\udcda Further Reading"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://en.wikipedia.org/wiki/Design_Patterns",children:"Gang of Four Design Patterns"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://refactoring.guru/design-patterns/strategy",children:"Strategy Pattern - Refactoring.Guru"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://www.dofactory.com/javascript/design-patterns/strategy",children:"JavaScript Strategy Pattern Examples"})}),"\n"]})]})}function h(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);