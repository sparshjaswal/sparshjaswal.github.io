"use strict";(globalThis.webpackChunka=globalThis.webpackChunka||[]).push([[4650],{6558:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>t,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"dsa-key-pattern/Two-Heaps","title":"Two Heaps","description":"Description","source":"@site/docs/dsa-key-pattern/16-Two-Heaps.md","sourceDirName":"dsa-key-pattern","slug":"/dsa-key-pattern/Two-Heaps","permalink":"/docs/dsa-key-pattern/Two-Heaps","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":16,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"K-way Merge","permalink":"/docs/dsa-key-pattern/K-way-Merge"},"next":{"title":"Monotonic Stack","permalink":"/docs/dsa-key-pattern/Monotonic-Stack"}}');var l=i(4848),a=i(8453);const r={},t="Two Heaps",d={},o=[{value:"Description",id:"description",level:2},{value:"Time Complexity",id:"time-complexity",level:2},{value:"Space Complexity",id:"space-complexity",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Key Problems",id:"key-problems",level:2},{value:"When to Use",id:"when-to-use",level:2},{value:"Pattern Recognition",id:"pattern-recognition",level:2},{value:"Algorithm Design",id:"algorithm-design",level:2},{value:"Heap Setup",id:"heap-setup",level:3},{value:"Insert Operation",id:"insert-operation",level:3},{value:"Find Median",id:"find-median",level:3},{value:"Variations",id:"variations",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"two-heaps",children:"Two Heaps"})}),"\n",(0,l.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,l.jsx)(n.p,{children:"This pattern uses two heaps (max heap and min heap) to solve problems involving tracking medians and efficiently managing dynamic data."}),"\n",(0,l.jsx)(n.h2,{id:"time-complexity",children:"Time Complexity"}),"\n",(0,l.jsx)(n.p,{children:"O(log n) for insertions"}),"\n",(0,l.jsx)(n.h2,{id:"space-complexity",children:"Space Complexity"}),"\n",(0,l.jsx)(n.p,{children:"O(n)"}),"\n",(0,l.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Max Heap + Min Heap"}),": Max heap for smaller half, min heap for larger half"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Balance Maintenance"}),": Keep heap sizes balanced (differ by at most 1)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Median Calculation"}),": Median is either top of larger heap or average of both tops"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Dynamic Updates"}),": Efficiently handle insertion of new elements"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"key-problems",children:"Key Problems"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Find Median from Data Stream"}),"\n",(0,l.jsx)(n.li,{children:"Sliding Window Median"}),"\n",(0,l.jsx)(n.li,{children:"IPO"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"when-to-use",children:"When to Use"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Finding median in dynamic dataset"}),"\n",(0,l.jsx)(n.li,{children:"Problems requiring quick access to middle elements"}),"\n",(0,l.jsx)(n.li,{children:"Sliding window problems involving medians"}),"\n",(0,l.jsx)(n.li,{children:"When you need to maintain sorted order partially"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"pattern-recognition",children:"Pattern Recognition"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:'"Find median from data stream"'}),"\n",(0,l.jsx)(n.li,{children:'"Sliding window median"'}),"\n",(0,l.jsx)(n.li,{children:'"Maintain median while adding elements"'}),"\n",(0,l.jsx)(n.li,{children:'"Quick access to middle elements"'}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"algorithm-design",children:"Algorithm Design"}),"\n",(0,l.jsx)(n.h3,{id:"heap-setup",children:"Heap Setup"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Max Heap"}),": Stores smaller half of numbers"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Min Heap"}),": Stores larger half of numbers"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Invariant"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"max_heap.size() === min_heap.size() || max_heap.size() === min_heap.size() + 1\n"})}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"insert-operation",children:"Insert Operation"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Add to appropriate heap"}),":"]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"   - If max_heap is empty or num \u2264 max_heap.top(): add to max_heap\r\n   - Otherwise: add to min_heap\r\n2. **Rebalance if needed**:\r\n   - If size difference > 1, move top element between heaps\n"})}),"\n",(0,l.jsx)(n.h3,{id:"find-median",children:"Find Median"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"- If max_heap.size() > min_heap.size(): return max_heap.top()\r\n- Otherwise: return (max_heap.top() + min_heap.top()) / 2\n"})}),"\n",(0,l.jsx)(n.h2,{id:"variations",children:"Variations"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Sliding Window"}),": Remove elements from heaps as window moves"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Weighted Median"}),": Modify for weighted elements"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Kth Element"}),": Generalize to find Kth smallest element"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>t});var s=i(6540);const l={},a=s.createContext(l);function r(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);