"use strict";(globalThis.webpackChunka=globalThis.webpackChunka||[]).push([[2892],{5587:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"dsa-key-pattern/Monotonic-Stack","title":"Monotonic Stack","description":"Description","source":"@site/docs/dsa-key-pattern/17-Monotonic-Stack.md","sourceDirName":"dsa-key-pattern","slug":"/dsa-key-pattern/Monotonic-Stack","permalink":"/docs/dsa-key-pattern/Monotonic-Stack","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":17,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Two Heaps","permalink":"/docs/dsa-key-pattern/Two-Heaps"},"next":{"title":"Trees","permalink":"/docs/dsa-key-pattern/Trees"}}');var t=i(4848),r=i(8453);const l={},c="Monotonic Stack",o={},a=[{value:"Description",id:"description",level:2},{value:"Time Complexity",id:"time-complexity",level:2},{value:"Space Complexity",id:"space-complexity",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Key Problems",id:"key-problems",level:2},{value:"When to Use",id:"when-to-use",level:2},{value:"Pattern Recognition",id:"pattern-recognition",level:2},{value:"Types of Monotonic Stacks",id:"types-of-monotonic-stacks",level:2},{value:"Increasing Stack (Non-decreasing)",id:"increasing-stack-non-decreasing",level:3},{value:"Decreasing Stack (Non-increasing)",id:"decreasing-stack-non-increasing",level:3},{value:"Algorithm Pattern",id:"algorithm-pattern",level:2},{value:"Applications",id:"applications",level:2}];function d(e){const n={h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"monotonic-stack",children:"Monotonic Stack"})}),"\n",(0,t.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,t.jsx)(n.p,{children:"A monotonic stack helps solve range queries by maintaining a stack of elements in increasing or decreasing order."}),"\n",(0,t.jsx)(n.h2,{id:"time-complexity",children:"Time Complexity"}),"\n",(0,t.jsx)(n.p,{children:"O(n)"}),"\n",(0,t.jsx)(n.h2,{id:"space-complexity",children:"Space Complexity"}),"\n",(0,t.jsx)(n.p,{children:"O(n)"}),"\n",(0,t.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Monotonic Property"}),": Stack maintains elements in strictly increasing/decreasing order"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Next Greater/Smaller"}),": Find next greater or smaller element for each array element"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Range Queries"}),": Efficiently solve problems involving ranges and comparisons"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Previous/Next Elements"}),": Track relationships between elements"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"key-problems",children:"Key Problems"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Next Greater Element II"}),"\n",(0,t.jsx)(n.li,{children:"Next Greater Node in Linked List"}),"\n",(0,t.jsx)(n.li,{children:"Daily Temperatures"}),"\n",(0,t.jsx)(n.li,{children:"Online Stock Span"}),"\n",(0,t.jsx)(n.li,{children:"Maximum Width Ramp"}),"\n",(0,t.jsx)(n.li,{children:"Largest Rectangle in Histogram"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"when-to-use",children:"When to Use"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Finding next/previous greater or smaller elements"}),"\n",(0,t.jsx)(n.li,{children:"Range-based problems with comparisons"}),"\n",(0,t.jsx)(n.li,{children:"Problems involving spans, widths, or areas"}),"\n",(0,t.jsx)(n.li,{children:"When you need to track relationships between elements"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"pattern-recognition",children:"Pattern Recognition"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:'"Next greater/smaller element"'}),"\n",(0,t.jsx)(n.li,{children:'"Temperature span problems"'}),"\n",(0,t.jsx)(n.li,{children:'"Largest rectangle in histogram"'}),"\n",(0,t.jsx)(n.li,{children:'"Maximum/minimum in ranges"'}),"\n",(0,t.jsx)(n.li,{children:'"Stock span problems"'}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"types-of-monotonic-stacks",children:"Types of Monotonic Stacks"}),"\n",(0,t.jsx)(n.h3,{id:"increasing-stack-non-decreasing",children:"Increasing Stack (Non-decreasing)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Maintains elements in increasing order"}),"\n",(0,t.jsx)(n.li,{children:"Used for finding next smaller elements"}),"\n",(0,t.jsx)(n.li,{children:"Pop elements when current element is smaller"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"decreasing-stack-non-increasing",children:"Decreasing Stack (Non-increasing)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Maintains elements in decreasing order"}),"\n",(0,t.jsx)(n.li,{children:"Used for finding next greater elements"}),"\n",(0,t.jsx)(n.li,{children:"Pop elements when current element is larger"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"algorithm-pattern",children:"Algorithm Pattern"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Initialize"}),": Empty stack"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"For each element"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["While stack is not empty AND stack.top() violates monotonic property:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Pop from stack and process relationship"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Push current element to stack"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Final processing"}),": Handle remaining elements in stack"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"applications",children:"Applications"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Next Greater Element"}),": Use decreasing stack"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Next Smaller Element"}),": Use increasing stack"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Largest Rectangle"}),": Classic histogram problem using increasing stack"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sliding Window Maximum"}),": Can be solved using monotonic deque"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>c});var s=i(6540);const t={},r=s.createContext(t);function l(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);